// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dms.proto

#ifndef PROTOBUF_dms_2eproto__INCLUDED
#define PROTOBUF_dms_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {
namespace dms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dms_2eproto();
void protobuf_AssignDesc_dms_2eproto();
void protobuf_ShutdownFile_dms_2eproto();

class DataPoint;
class Trade;
class BBO;
class Bid;
class Offer;
class L2;
class Contract;

enum ContractType {
  CT_None = 0,
  CT_Futures = 1,
  CT_Spread = 2
};
bool ContractType_IsValid(int value);
const ContractType ContractType_MIN = CT_None;
const ContractType ContractType_MAX = CT_Spread;
const int ContractType_ARRAYSIZE = ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContractType_descriptor();
inline const ::std::string& ContractType_Name(ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContractType_descriptor(), value);
}
inline bool ContractType_Parse(
    const ::std::string& name, ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractType>(
    ContractType_descriptor(), name, value);
}
// ===================================================================

class DataPoint : public ::google::protobuf::Message {
 public:
  DataPoint();
  virtual ~DataPoint();

  DataPoint(const DataPoint& from);

  inline DataPoint& operator=(const DataPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataPoint& default_instance();

  void Swap(DataPoint* other);

  // implements Message ----------------------------------------------

  DataPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataPoint& from);
  void MergeFrom(const DataPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double price = 1;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 1;
  inline double price() const;
  inline void set_price(double value);

  // optional uint64 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.dms.DataPoint)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  ::google::protobuf::uint64 size_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static DataPoint* default_instance_;
};
// -------------------------------------------------------------------

class Trade : public ::google::protobuf::Message {
 public:
  Trade();
  virtual ~Trade();

  Trade(const Trade& from);

  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trade& default_instance();

  void Swap(Trade* other);

  // implements Message ----------------------------------------------

  Trade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trade& from);
  void MergeFrom(const Trade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contract = 1;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 1;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.dms.DataPoint last = 2;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 2;
  inline const ::pb::dms::DataPoint& last() const;
  inline ::pb::dms::DataPoint* mutable_last();
  inline ::pb::dms::DataPoint* release_last();
  inline void set_allocated_last(::pb::dms::DataPoint* last);

  // @@protoc_insertion_point(class_scope:pb.dms.Trade)
 private:
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_last();
  inline void clear_has_last();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contract_;
  ::pb::dms::DataPoint* last_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static Trade* default_instance_;
};
// -------------------------------------------------------------------

class BBO : public ::google::protobuf::Message {
 public:
  BBO();
  virtual ~BBO();

  BBO(const BBO& from);

  inline BBO& operator=(const BBO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BBO& default_instance();

  void Swap(BBO* other);

  // implements Message ----------------------------------------------

  BBO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BBO& from);
  void MergeFrom(const BBO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contract = 1;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 1;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.dms.DataPoint bid = 2;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 2;
  inline const ::pb::dms::DataPoint& bid() const;
  inline ::pb::dms::DataPoint* mutable_bid();
  inline ::pb::dms::DataPoint* release_bid();
  inline void set_allocated_bid(::pb::dms::DataPoint* bid);

  // optional .pb.dms.DataPoint offer = 3;
  inline bool has_offer() const;
  inline void clear_offer();
  static const int kOfferFieldNumber = 3;
  inline const ::pb::dms::DataPoint& offer() const;
  inline ::pb::dms::DataPoint* mutable_offer();
  inline ::pb::dms::DataPoint* release_offer();
  inline void set_allocated_offer(::pb::dms::DataPoint* offer);

  // @@protoc_insertion_point(class_scope:pb.dms.BBO)
 private:
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_offer();
  inline void clear_has_offer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contract_;
  ::pb::dms::DataPoint* bid_;
  ::pb::dms::DataPoint* offer_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static BBO* default_instance_;
};
// -------------------------------------------------------------------

class Bid : public ::google::protobuf::Message {
 public:
  Bid();
  virtual ~Bid();

  Bid(const Bid& from);

  inline Bid& operator=(const Bid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bid& default_instance();

  void Swap(Bid* other);

  // implements Message ----------------------------------------------

  Bid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bid& from);
  void MergeFrom(const Bid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contract = 1;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 1;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.dms.DataPoint bid = 2;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 2;
  inline const ::pb::dms::DataPoint& bid() const;
  inline ::pb::dms::DataPoint* mutable_bid();
  inline ::pb::dms::DataPoint* release_bid();
  inline void set_allocated_bid(::pb::dms::DataPoint* bid);

  // @@protoc_insertion_point(class_scope:pb.dms.Bid)
 private:
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_bid();
  inline void clear_has_bid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contract_;
  ::pb::dms::DataPoint* bid_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static Bid* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();

  void Swap(Offer* other);

  // implements Message ----------------------------------------------

  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contract = 1;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 1;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.dms.DataPoint offer = 2;
  inline bool has_offer() const;
  inline void clear_offer();
  static const int kOfferFieldNumber = 2;
  inline const ::pb::dms::DataPoint& offer() const;
  inline ::pb::dms::DataPoint* mutable_offer();
  inline ::pb::dms::DataPoint* release_offer();
  inline void set_allocated_offer(::pb::dms::DataPoint* offer);

  // @@protoc_insertion_point(class_scope:pb.dms.Offer)
 private:
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_offer();
  inline void clear_has_offer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contract_;
  ::pb::dms::DataPoint* offer_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class L2 : public ::google::protobuf::Message {
 public:
  L2();
  virtual ~L2();

  L2(const L2& from);

  inline L2& operator=(const L2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const L2& default_instance();

  void Swap(L2* other);

  // implements Message ----------------------------------------------

  L2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const L2& from);
  void MergeFrom(const L2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contract = 1;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 1;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // repeated .pb.dms.DataPoint bid = 2;
  inline int bid_size() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 2;
  inline const ::pb::dms::DataPoint& bid(int index) const;
  inline ::pb::dms::DataPoint* mutable_bid(int index);
  inline ::pb::dms::DataPoint* add_bid();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >&
      bid() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >*
      mutable_bid();

  // repeated .pb.dms.DataPoint offer = 3;
  inline int offer_size() const;
  inline void clear_offer();
  static const int kOfferFieldNumber = 3;
  inline const ::pb::dms::DataPoint& offer(int index) const;
  inline ::pb::dms::DataPoint* mutable_offer(int index);
  inline ::pb::dms::DataPoint* add_offer();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >&
      offer() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >*
      mutable_offer();

  // @@protoc_insertion_point(class_scope:pb.dms.L2)
 private:
  inline void set_has_contract();
  inline void clear_has_contract();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contract_;
  ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint > bid_;
  ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint > offer_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static L2* default_instance_;
};
// -------------------------------------------------------------------

class Contract : public ::google::protobuf::Message {
 public:
  Contract();
  virtual ~Contract();

  Contract(const Contract& from);

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Contract& default_instance();

  void Swap(Contract* other);

  // implements Message ----------------------------------------------

  Contract* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contract& from);
  void MergeFrom(const Contract& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string tick_size = 2;
  inline bool has_tick_size() const;
  inline void clear_tick_size();
  static const int kTickSizeFieldNumber = 2;
  inline const ::std::string& tick_size() const;
  inline void set_tick_size(const ::std::string& value);
  inline void set_tick_size(const char* value);
  inline void set_tick_size(const char* value, size_t size);
  inline ::std::string* mutable_tick_size();
  inline ::std::string* release_tick_size();
  inline void set_allocated_tick_size(::std::string* tick_size);

  // optional string tick_value = 3;
  inline bool has_tick_value() const;
  inline void clear_tick_value();
  static const int kTickValueFieldNumber = 3;
  inline const ::std::string& tick_value() const;
  inline void set_tick_value(const ::std::string& value);
  inline void set_tick_value(const char* value);
  inline void set_tick_value(const char* value, size_t size);
  inline ::std::string* mutable_tick_value();
  inline ::std::string* release_tick_value();
  inline void set_allocated_tick_value(::std::string* tick_value);

  // optional string yesterday_close_price = 4;
  inline bool has_yesterday_close_price() const;
  inline void clear_yesterday_close_price();
  static const int kYesterdayClosePriceFieldNumber = 4;
  inline const ::std::string& yesterday_close_price() const;
  inline void set_yesterday_close_price(const ::std::string& value);
  inline void set_yesterday_close_price(const char* value);
  inline void set_yesterday_close_price(const char* value, size_t size);
  inline ::std::string* mutable_yesterday_close_price();
  inline ::std::string* release_yesterday_close_price();
  inline void set_allocated_yesterday_close_price(::std::string* yesterday_close_price);

  // optional string upper_limit = 5;
  inline bool has_upper_limit() const;
  inline void clear_upper_limit();
  static const int kUpperLimitFieldNumber = 5;
  inline const ::std::string& upper_limit() const;
  inline void set_upper_limit(const ::std::string& value);
  inline void set_upper_limit(const char* value);
  inline void set_upper_limit(const char* value, size_t size);
  inline ::std::string* mutable_upper_limit();
  inline ::std::string* release_upper_limit();
  inline void set_allocated_upper_limit(::std::string* upper_limit);

  // optional string lower_limit = 6;
  inline bool has_lower_limit() const;
  inline void clear_lower_limit();
  static const int kLowerLimitFieldNumber = 6;
  inline const ::std::string& lower_limit() const;
  inline void set_lower_limit(const ::std::string& value);
  inline void set_lower_limit(const char* value);
  inline void set_lower_limit(const char* value, size_t size);
  inline ::std::string* mutable_lower_limit();
  inline ::std::string* release_lower_limit();
  inline void set_allocated_lower_limit(::std::string* lower_limit);

  // optional .pb.dms.ContractType contract_type = 7;
  inline bool has_contract_type() const;
  inline void clear_contract_type();
  static const int kContractTypeFieldNumber = 7;
  inline ::pb::dms::ContractType contract_type() const;
  inline void set_contract_type(::pb::dms::ContractType value);

  // optional string legA = 8;
  inline bool has_lega() const;
  inline void clear_lega();
  static const int kLegAFieldNumber = 8;
  inline const ::std::string& lega() const;
  inline void set_lega(const ::std::string& value);
  inline void set_lega(const char* value);
  inline void set_lega(const char* value, size_t size);
  inline ::std::string* mutable_lega();
  inline ::std::string* release_lega();
  inline void set_allocated_lega(::std::string* lega);

  // optional string legB = 9;
  inline bool has_legb() const;
  inline void clear_legb();
  static const int kLegBFieldNumber = 9;
  inline const ::std::string& legb() const;
  inline void set_legb(const ::std::string& value);
  inline void set_legb(const char* value);
  inline void set_legb(const char* value, size_t size);
  inline ::std::string* mutable_legb();
  inline ::std::string* release_legb();
  inline void set_allocated_legb(::std::string* legb);

  // @@protoc_insertion_point(class_scope:pb.dms.Contract)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tick_size();
  inline void clear_has_tick_size();
  inline void set_has_tick_value();
  inline void clear_has_tick_value();
  inline void set_has_yesterday_close_price();
  inline void clear_has_yesterday_close_price();
  inline void set_has_upper_limit();
  inline void clear_has_upper_limit();
  inline void set_has_lower_limit();
  inline void clear_has_lower_limit();
  inline void set_has_contract_type();
  inline void clear_has_contract_type();
  inline void set_has_lega();
  inline void clear_has_lega();
  inline void set_has_legb();
  inline void clear_has_legb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* tick_size_;
  ::std::string* tick_value_;
  ::std::string* yesterday_close_price_;
  ::std::string* upper_limit_;
  ::std::string* lower_limit_;
  ::std::string* lega_;
  ::std::string* legb_;
  int contract_type_;
  friend void  protobuf_AddDesc_dms_2eproto();
  friend void protobuf_AssignDesc_dms_2eproto();
  friend void protobuf_ShutdownFile_dms_2eproto();

  void InitAsDefaultInstance();
  static Contract* default_instance_;
};
// ===================================================================


// ===================================================================

// DataPoint

// optional double price = 1;
inline bool DataPoint::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataPoint::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataPoint::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataPoint::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double DataPoint::price() const {
  // @@protoc_insertion_point(field_get:pb.dms.DataPoint.price)
  return price_;
}
inline void DataPoint::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:pb.dms.DataPoint.price)
}

// optional uint64 size = 2;
inline bool DataPoint::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataPoint::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataPoint::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataPoint::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 DataPoint::size() const {
  // @@protoc_insertion_point(field_get:pb.dms.DataPoint.size)
  return size_;
}
inline void DataPoint::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:pb.dms.DataPoint.size)
}

// -------------------------------------------------------------------

// Trade

// optional string contract = 1;
inline bool Trade::has_contract() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trade::set_has_contract() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trade::clear_has_contract() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trade::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& Trade::contract() const {
  // @@protoc_insertion_point(field_get:pb.dms.Trade.contract)
  return *contract_;
}
inline void Trade::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Trade.contract)
}
inline void Trade::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Trade.contract)
}
inline void Trade::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Trade.contract)
}
inline ::std::string* Trade::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Trade.contract)
  return contract_;
}
inline ::std::string* Trade::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Trade::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Trade.contract)
}

// optional .pb.dms.DataPoint last = 2;
inline bool Trade::has_last() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trade::set_has_last() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trade::clear_has_last() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trade::clear_last() {
  if (last_ != NULL) last_->::pb::dms::DataPoint::Clear();
  clear_has_last();
}
inline const ::pb::dms::DataPoint& Trade::last() const {
  // @@protoc_insertion_point(field_get:pb.dms.Trade.last)
  return last_ != NULL ? *last_ : *default_instance_->last_;
}
inline ::pb::dms::DataPoint* Trade::mutable_last() {
  set_has_last();
  if (last_ == NULL) last_ = new ::pb::dms::DataPoint;
  // @@protoc_insertion_point(field_mutable:pb.dms.Trade.last)
  return last_;
}
inline ::pb::dms::DataPoint* Trade::release_last() {
  clear_has_last();
  ::pb::dms::DataPoint* temp = last_;
  last_ = NULL;
  return temp;
}
inline void Trade::set_allocated_last(::pb::dms::DataPoint* last) {
  delete last_;
  last_ = last;
  if (last) {
    set_has_last();
  } else {
    clear_has_last();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Trade.last)
}

// -------------------------------------------------------------------

// BBO

// optional string contract = 1;
inline bool BBO::has_contract() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BBO::set_has_contract() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BBO::clear_has_contract() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BBO::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& BBO::contract() const {
  // @@protoc_insertion_point(field_get:pb.dms.BBO.contract)
  return *contract_;
}
inline void BBO::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.BBO.contract)
}
inline void BBO::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.BBO.contract)
}
inline void BBO::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.BBO.contract)
}
inline ::std::string* BBO::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.BBO.contract)
  return contract_;
}
inline ::std::string* BBO::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BBO::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.BBO.contract)
}

// optional .pb.dms.DataPoint bid = 2;
inline bool BBO::has_bid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BBO::set_has_bid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BBO::clear_has_bid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BBO::clear_bid() {
  if (bid_ != NULL) bid_->::pb::dms::DataPoint::Clear();
  clear_has_bid();
}
inline const ::pb::dms::DataPoint& BBO::bid() const {
  // @@protoc_insertion_point(field_get:pb.dms.BBO.bid)
  return bid_ != NULL ? *bid_ : *default_instance_->bid_;
}
inline ::pb::dms::DataPoint* BBO::mutable_bid() {
  set_has_bid();
  if (bid_ == NULL) bid_ = new ::pb::dms::DataPoint;
  // @@protoc_insertion_point(field_mutable:pb.dms.BBO.bid)
  return bid_;
}
inline ::pb::dms::DataPoint* BBO::release_bid() {
  clear_has_bid();
  ::pb::dms::DataPoint* temp = bid_;
  bid_ = NULL;
  return temp;
}
inline void BBO::set_allocated_bid(::pb::dms::DataPoint* bid) {
  delete bid_;
  bid_ = bid;
  if (bid) {
    set_has_bid();
  } else {
    clear_has_bid();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.BBO.bid)
}

// optional .pb.dms.DataPoint offer = 3;
inline bool BBO::has_offer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BBO::set_has_offer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BBO::clear_has_offer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BBO::clear_offer() {
  if (offer_ != NULL) offer_->::pb::dms::DataPoint::Clear();
  clear_has_offer();
}
inline const ::pb::dms::DataPoint& BBO::offer() const {
  // @@protoc_insertion_point(field_get:pb.dms.BBO.offer)
  return offer_ != NULL ? *offer_ : *default_instance_->offer_;
}
inline ::pb::dms::DataPoint* BBO::mutable_offer() {
  set_has_offer();
  if (offer_ == NULL) offer_ = new ::pb::dms::DataPoint;
  // @@protoc_insertion_point(field_mutable:pb.dms.BBO.offer)
  return offer_;
}
inline ::pb::dms::DataPoint* BBO::release_offer() {
  clear_has_offer();
  ::pb::dms::DataPoint* temp = offer_;
  offer_ = NULL;
  return temp;
}
inline void BBO::set_allocated_offer(::pb::dms::DataPoint* offer) {
  delete offer_;
  offer_ = offer;
  if (offer) {
    set_has_offer();
  } else {
    clear_has_offer();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.BBO.offer)
}

// -------------------------------------------------------------------

// Bid

// optional string contract = 1;
inline bool Bid::has_contract() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bid::set_has_contract() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bid::clear_has_contract() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bid::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& Bid::contract() const {
  // @@protoc_insertion_point(field_get:pb.dms.Bid.contract)
  return *contract_;
}
inline void Bid::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Bid.contract)
}
inline void Bid::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Bid.contract)
}
inline void Bid::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Bid.contract)
}
inline ::std::string* Bid::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Bid.contract)
  return contract_;
}
inline ::std::string* Bid::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Bid.contract)
}

// optional .pb.dms.DataPoint bid = 2;
inline bool Bid::has_bid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bid::set_has_bid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bid::clear_has_bid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bid::clear_bid() {
  if (bid_ != NULL) bid_->::pb::dms::DataPoint::Clear();
  clear_has_bid();
}
inline const ::pb::dms::DataPoint& Bid::bid() const {
  // @@protoc_insertion_point(field_get:pb.dms.Bid.bid)
  return bid_ != NULL ? *bid_ : *default_instance_->bid_;
}
inline ::pb::dms::DataPoint* Bid::mutable_bid() {
  set_has_bid();
  if (bid_ == NULL) bid_ = new ::pb::dms::DataPoint;
  // @@protoc_insertion_point(field_mutable:pb.dms.Bid.bid)
  return bid_;
}
inline ::pb::dms::DataPoint* Bid::release_bid() {
  clear_has_bid();
  ::pb::dms::DataPoint* temp = bid_;
  bid_ = NULL;
  return temp;
}
inline void Bid::set_allocated_bid(::pb::dms::DataPoint* bid) {
  delete bid_;
  bid_ = bid;
  if (bid) {
    set_has_bid();
  } else {
    clear_has_bid();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Bid.bid)
}

// -------------------------------------------------------------------

// Offer

// optional string contract = 1;
inline bool Offer::has_contract() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_contract() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_contract() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& Offer::contract() const {
  // @@protoc_insertion_point(field_get:pb.dms.Offer.contract)
  return *contract_;
}
inline void Offer::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Offer.contract)
}
inline void Offer::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Offer.contract)
}
inline void Offer::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Offer.contract)
}
inline ::std::string* Offer::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Offer.contract)
  return contract_;
}
inline ::std::string* Offer::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Offer::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Offer.contract)
}

// optional .pb.dms.DataPoint offer = 2;
inline bool Offer::has_offer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_offer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_offer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_offer() {
  if (offer_ != NULL) offer_->::pb::dms::DataPoint::Clear();
  clear_has_offer();
}
inline const ::pb::dms::DataPoint& Offer::offer() const {
  // @@protoc_insertion_point(field_get:pb.dms.Offer.offer)
  return offer_ != NULL ? *offer_ : *default_instance_->offer_;
}
inline ::pb::dms::DataPoint* Offer::mutable_offer() {
  set_has_offer();
  if (offer_ == NULL) offer_ = new ::pb::dms::DataPoint;
  // @@protoc_insertion_point(field_mutable:pb.dms.Offer.offer)
  return offer_;
}
inline ::pb::dms::DataPoint* Offer::release_offer() {
  clear_has_offer();
  ::pb::dms::DataPoint* temp = offer_;
  offer_ = NULL;
  return temp;
}
inline void Offer::set_allocated_offer(::pb::dms::DataPoint* offer) {
  delete offer_;
  offer_ = offer;
  if (offer) {
    set_has_offer();
  } else {
    clear_has_offer();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Offer.offer)
}

// -------------------------------------------------------------------

// L2

// optional string contract = 1;
inline bool L2::has_contract() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void L2::set_has_contract() {
  _has_bits_[0] |= 0x00000001u;
}
inline void L2::clear_has_contract() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void L2::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& L2::contract() const {
  // @@protoc_insertion_point(field_get:pb.dms.L2.contract)
  return *contract_;
}
inline void L2::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.L2.contract)
}
inline void L2::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.L2.contract)
}
inline void L2::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.L2.contract)
}
inline ::std::string* L2::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.L2.contract)
  return contract_;
}
inline ::std::string* L2::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void L2::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.L2.contract)
}

// repeated .pb.dms.DataPoint bid = 2;
inline int L2::bid_size() const {
  return bid_.size();
}
inline void L2::clear_bid() {
  bid_.Clear();
}
inline const ::pb::dms::DataPoint& L2::bid(int index) const {
  // @@protoc_insertion_point(field_get:pb.dms.L2.bid)
  return bid_.Get(index);
}
inline ::pb::dms::DataPoint* L2::mutable_bid(int index) {
  // @@protoc_insertion_point(field_mutable:pb.dms.L2.bid)
  return bid_.Mutable(index);
}
inline ::pb::dms::DataPoint* L2::add_bid() {
  // @@protoc_insertion_point(field_add:pb.dms.L2.bid)
  return bid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >&
L2::bid() const {
  // @@protoc_insertion_point(field_list:pb.dms.L2.bid)
  return bid_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >*
L2::mutable_bid() {
  // @@protoc_insertion_point(field_mutable_list:pb.dms.L2.bid)
  return &bid_;
}

// repeated .pb.dms.DataPoint offer = 3;
inline int L2::offer_size() const {
  return offer_.size();
}
inline void L2::clear_offer() {
  offer_.Clear();
}
inline const ::pb::dms::DataPoint& L2::offer(int index) const {
  // @@protoc_insertion_point(field_get:pb.dms.L2.offer)
  return offer_.Get(index);
}
inline ::pb::dms::DataPoint* L2::mutable_offer(int index) {
  // @@protoc_insertion_point(field_mutable:pb.dms.L2.offer)
  return offer_.Mutable(index);
}
inline ::pb::dms::DataPoint* L2::add_offer() {
  // @@protoc_insertion_point(field_add:pb.dms.L2.offer)
  return offer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >&
L2::offer() const {
  // @@protoc_insertion_point(field_list:pb.dms.L2.offer)
  return offer_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::dms::DataPoint >*
L2::mutable_offer() {
  // @@protoc_insertion_point(field_mutable_list:pb.dms.L2.offer)
  return &offer_;
}

// -------------------------------------------------------------------

// Contract

// required string name = 1;
inline bool Contract::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contract::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contract::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contract::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Contract::name() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.name)
  return *name_;
}
inline void Contract::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.name)
}
inline void Contract::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.name)
}
inline void Contract::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.name)
}
inline ::std::string* Contract::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.name)
  return name_;
}
inline ::std::string* Contract::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.name)
}

// required string tick_size = 2;
inline bool Contract::has_tick_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contract::set_has_tick_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contract::clear_has_tick_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contract::clear_tick_size() {
  if (tick_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_size_->clear();
  }
  clear_has_tick_size();
}
inline const ::std::string& Contract::tick_size() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.tick_size)
  return *tick_size_;
}
inline void Contract::set_tick_size(const ::std::string& value) {
  set_has_tick_size();
  if (tick_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_size_ = new ::std::string;
  }
  tick_size_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.tick_size)
}
inline void Contract::set_tick_size(const char* value) {
  set_has_tick_size();
  if (tick_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_size_ = new ::std::string;
  }
  tick_size_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.tick_size)
}
inline void Contract::set_tick_size(const char* value, size_t size) {
  set_has_tick_size();
  if (tick_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_size_ = new ::std::string;
  }
  tick_size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.tick_size)
}
inline ::std::string* Contract::mutable_tick_size() {
  set_has_tick_size();
  if (tick_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.tick_size)
  return tick_size_;
}
inline ::std::string* Contract::release_tick_size() {
  clear_has_tick_size();
  if (tick_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tick_size_;
    tick_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_tick_size(::std::string* tick_size) {
  if (tick_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tick_size_;
  }
  if (tick_size) {
    set_has_tick_size();
    tick_size_ = tick_size;
  } else {
    clear_has_tick_size();
    tick_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.tick_size)
}

// optional string tick_value = 3;
inline bool Contract::has_tick_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contract::set_has_tick_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contract::clear_has_tick_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contract::clear_tick_value() {
  if (tick_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_value_->clear();
  }
  clear_has_tick_value();
}
inline const ::std::string& Contract::tick_value() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.tick_value)
  return *tick_value_;
}
inline void Contract::set_tick_value(const ::std::string& value) {
  set_has_tick_value();
  if (tick_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_value_ = new ::std::string;
  }
  tick_value_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.tick_value)
}
inline void Contract::set_tick_value(const char* value) {
  set_has_tick_value();
  if (tick_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_value_ = new ::std::string;
  }
  tick_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.tick_value)
}
inline void Contract::set_tick_value(const char* value, size_t size) {
  set_has_tick_value();
  if (tick_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_value_ = new ::std::string;
  }
  tick_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.tick_value)
}
inline ::std::string* Contract::mutable_tick_value() {
  set_has_tick_value();
  if (tick_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tick_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.tick_value)
  return tick_value_;
}
inline ::std::string* Contract::release_tick_value() {
  clear_has_tick_value();
  if (tick_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tick_value_;
    tick_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_tick_value(::std::string* tick_value) {
  if (tick_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tick_value_;
  }
  if (tick_value) {
    set_has_tick_value();
    tick_value_ = tick_value;
  } else {
    clear_has_tick_value();
    tick_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.tick_value)
}

// optional string yesterday_close_price = 4;
inline bool Contract::has_yesterday_close_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Contract::set_has_yesterday_close_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Contract::clear_has_yesterday_close_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Contract::clear_yesterday_close_price() {
  if (yesterday_close_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yesterday_close_price_->clear();
  }
  clear_has_yesterday_close_price();
}
inline const ::std::string& Contract::yesterday_close_price() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.yesterday_close_price)
  return *yesterday_close_price_;
}
inline void Contract::set_yesterday_close_price(const ::std::string& value) {
  set_has_yesterday_close_price();
  if (yesterday_close_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yesterday_close_price_ = new ::std::string;
  }
  yesterday_close_price_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.yesterday_close_price)
}
inline void Contract::set_yesterday_close_price(const char* value) {
  set_has_yesterday_close_price();
  if (yesterday_close_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yesterday_close_price_ = new ::std::string;
  }
  yesterday_close_price_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.yesterday_close_price)
}
inline void Contract::set_yesterday_close_price(const char* value, size_t size) {
  set_has_yesterday_close_price();
  if (yesterday_close_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yesterday_close_price_ = new ::std::string;
  }
  yesterday_close_price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.yesterday_close_price)
}
inline ::std::string* Contract::mutable_yesterday_close_price() {
  set_has_yesterday_close_price();
  if (yesterday_close_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yesterday_close_price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.yesterday_close_price)
  return yesterday_close_price_;
}
inline ::std::string* Contract::release_yesterday_close_price() {
  clear_has_yesterday_close_price();
  if (yesterday_close_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = yesterday_close_price_;
    yesterday_close_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_yesterday_close_price(::std::string* yesterday_close_price) {
  if (yesterday_close_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete yesterday_close_price_;
  }
  if (yesterday_close_price) {
    set_has_yesterday_close_price();
    yesterday_close_price_ = yesterday_close_price;
  } else {
    clear_has_yesterday_close_price();
    yesterday_close_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.yesterday_close_price)
}

// optional string upper_limit = 5;
inline bool Contract::has_upper_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Contract::set_has_upper_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Contract::clear_has_upper_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Contract::clear_upper_limit() {
  if (upper_limit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    upper_limit_->clear();
  }
  clear_has_upper_limit();
}
inline const ::std::string& Contract::upper_limit() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.upper_limit)
  return *upper_limit_;
}
inline void Contract::set_upper_limit(const ::std::string& value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.upper_limit)
}
inline void Contract::set_upper_limit(const char* value) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.upper_limit)
}
inline void Contract::set_upper_limit(const char* value, size_t size) {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    upper_limit_ = new ::std::string;
  }
  upper_limit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.upper_limit)
}
inline ::std::string* Contract::mutable_upper_limit() {
  set_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    upper_limit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.upper_limit)
  return upper_limit_;
}
inline ::std::string* Contract::release_upper_limit() {
  clear_has_upper_limit();
  if (upper_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = upper_limit_;
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_upper_limit(::std::string* upper_limit) {
  if (upper_limit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete upper_limit_;
  }
  if (upper_limit) {
    set_has_upper_limit();
    upper_limit_ = upper_limit;
  } else {
    clear_has_upper_limit();
    upper_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.upper_limit)
}

// optional string lower_limit = 6;
inline bool Contract::has_lower_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Contract::set_has_lower_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Contract::clear_has_lower_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Contract::clear_lower_limit() {
  if (lower_limit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lower_limit_->clear();
  }
  clear_has_lower_limit();
}
inline const ::std::string& Contract::lower_limit() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.lower_limit)
  return *lower_limit_;
}
inline void Contract::set_lower_limit(const ::std::string& value) {
  set_has_lower_limit();
  if (lower_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lower_limit_ = new ::std::string;
  }
  lower_limit_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.lower_limit)
}
inline void Contract::set_lower_limit(const char* value) {
  set_has_lower_limit();
  if (lower_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lower_limit_ = new ::std::string;
  }
  lower_limit_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.lower_limit)
}
inline void Contract::set_lower_limit(const char* value, size_t size) {
  set_has_lower_limit();
  if (lower_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lower_limit_ = new ::std::string;
  }
  lower_limit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.lower_limit)
}
inline ::std::string* Contract::mutable_lower_limit() {
  set_has_lower_limit();
  if (lower_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lower_limit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.lower_limit)
  return lower_limit_;
}
inline ::std::string* Contract::release_lower_limit() {
  clear_has_lower_limit();
  if (lower_limit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lower_limit_;
    lower_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_lower_limit(::std::string* lower_limit) {
  if (lower_limit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lower_limit_;
  }
  if (lower_limit) {
    set_has_lower_limit();
    lower_limit_ = lower_limit;
  } else {
    clear_has_lower_limit();
    lower_limit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.lower_limit)
}

// optional .pb.dms.ContractType contract_type = 7;
inline bool Contract::has_contract_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Contract::set_has_contract_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Contract::clear_has_contract_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Contract::clear_contract_type() {
  contract_type_ = 0;
  clear_has_contract_type();
}
inline ::pb::dms::ContractType Contract::contract_type() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.contract_type)
  return static_cast< ::pb::dms::ContractType >(contract_type_);
}
inline void Contract::set_contract_type(::pb::dms::ContractType value) {
  assert(::pb::dms::ContractType_IsValid(value));
  set_has_contract_type();
  contract_type_ = value;
  // @@protoc_insertion_point(field_set:pb.dms.Contract.contract_type)
}

// optional string legA = 8;
inline bool Contract::has_lega() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Contract::set_has_lega() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Contract::clear_has_lega() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Contract::clear_lega() {
  if (lega_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lega_->clear();
  }
  clear_has_lega();
}
inline const ::std::string& Contract::lega() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.legA)
  return *lega_;
}
inline void Contract::set_lega(const ::std::string& value) {
  set_has_lega();
  if (lega_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lega_ = new ::std::string;
  }
  lega_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.legA)
}
inline void Contract::set_lega(const char* value) {
  set_has_lega();
  if (lega_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lega_ = new ::std::string;
  }
  lega_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.legA)
}
inline void Contract::set_lega(const char* value, size_t size) {
  set_has_lega();
  if (lega_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lega_ = new ::std::string;
  }
  lega_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.legA)
}
inline ::std::string* Contract::mutable_lega() {
  set_has_lega();
  if (lega_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lega_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.legA)
  return lega_;
}
inline ::std::string* Contract::release_lega() {
  clear_has_lega();
  if (lega_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lega_;
    lega_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_lega(::std::string* lega) {
  if (lega_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lega_;
  }
  if (lega) {
    set_has_lega();
    lega_ = lega;
  } else {
    clear_has_lega();
    lega_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.legA)
}

// optional string legB = 9;
inline bool Contract::has_legb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Contract::set_has_legb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Contract::clear_has_legb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Contract::clear_legb() {
  if (legb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    legb_->clear();
  }
  clear_has_legb();
}
inline const ::std::string& Contract::legb() const {
  // @@protoc_insertion_point(field_get:pb.dms.Contract.legB)
  return *legb_;
}
inline void Contract::set_legb(const ::std::string& value) {
  set_has_legb();
  if (legb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    legb_ = new ::std::string;
  }
  legb_->assign(value);
  // @@protoc_insertion_point(field_set:pb.dms.Contract.legB)
}
inline void Contract::set_legb(const char* value) {
  set_has_legb();
  if (legb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    legb_ = new ::std::string;
  }
  legb_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.dms.Contract.legB)
}
inline void Contract::set_legb(const char* value, size_t size) {
  set_has_legb();
  if (legb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    legb_ = new ::std::string;
  }
  legb_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.dms.Contract.legB)
}
inline ::std::string* Contract::mutable_legb() {
  set_has_legb();
  if (legb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    legb_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.dms.Contract.legB)
  return legb_;
}
inline ::std::string* Contract::release_legb() {
  clear_has_legb();
  if (legb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = legb_;
    legb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Contract::set_allocated_legb(::std::string* legb) {
  if (legb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete legb_;
  }
  if (legb) {
    set_has_legb();
    legb_ = legb;
  } else {
    clear_has_legb();
    legb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.dms.Contract.legB)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dms
}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::dms::ContractType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::dms::ContractType>() {
  return ::pb::dms::ContractType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dms_2eproto__INCLUDED
