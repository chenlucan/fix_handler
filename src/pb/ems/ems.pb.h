// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ems.proto

#ifndef PROTOBUF_ems_2eproto__INCLUDED
#define PROTOBUF_ems_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {
namespace ems {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ems_2eproto();
void protobuf_AssignDesc_ems_2eproto();
void protobuf_ShutdownFile_ems_2eproto();

class Date;
class Time;
class Timestamp;
class Status;
class Order;
class Fill;

enum Status_Code {
  Status_Code_OK = 0,
  Status_Code_FAILED = 1
};
bool Status_Code_IsValid(int value);
const Status_Code Status_Code_Code_MIN = Status_Code_OK;
const Status_Code Status_Code_Code_MAX = Status_Code_FAILED;
const int Status_Code_Code_ARRAYSIZE = Status_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_Code_descriptor();
inline const ::std::string& Status_Code_Name(Status_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_Code_descriptor(), value);
}
inline bool Status_Code_Parse(
    const ::std::string& name, Status_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_Code>(
    Status_Code_descriptor(), name, value);
}
enum BuySell {
  BS_None = 0,
  BS_Buy = 1,
  BS_Sell = 2
};
bool BuySell_IsValid(int value);
const BuySell BuySell_MIN = BS_None;
const BuySell BuySell_MAX = BS_Sell;
const int BuySell_ARRAYSIZE = BuySell_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuySell_descriptor();
inline const ::std::string& BuySell_Name(BuySell value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuySell_descriptor(), value);
}
inline bool BuySell_Parse(
    const ::std::string& name, BuySell* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuySell>(
    BuySell_descriptor(), name, value);
}
enum OrderStatus {
  OS_None = 0,
  OS_Cancelled = 1,
  OS_Filled = 2,
  OS_Rejected = 3,
  OS_Working = 4,
  OS_Pending = 5
};
bool OrderStatus_IsValid(int value);
const OrderStatus OrderStatus_MIN = OS_None;
const OrderStatus OrderStatus_MAX = OS_Pending;
const int OrderStatus_ARRAYSIZE = OrderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor();
inline const ::std::string& OrderStatus_Name(OrderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatus_descriptor(), value);
}
inline bool OrderStatus_Parse(
    const ::std::string& name, OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatus>(
    OrderStatus_descriptor(), name, value);
}
enum TimeInForce {
  TIF_None = 0,
  TIF_FAK = 1,
  TIF_FOK = 2,
  TIF_GFD = 3,
  TIF_GTC = 4
};
bool TimeInForce_IsValid(int value);
const TimeInForce TimeInForce_MIN = TIF_None;
const TimeInForce TimeInForce_MAX = TIF_GTC;
const int TimeInForce_ARRAYSIZE = TimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForce_descriptor();
inline const ::std::string& TimeInForce_Name(TimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForce_descriptor(), value);
}
inline bool TimeInForce_Parse(
    const ::std::string& name, TimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForce>(
    TimeInForce_descriptor(), name, value);
}
enum OrderType {
  OT_None = 0,
  OT_Limit = 1,
  OT_Market = 2
};
bool OrderType_IsValid(int value);
const OrderType OrderType_MIN = OT_None;
const OrderType OrderType_MAX = OT_Market;
const int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderType_descriptor();
inline const ::std::string& OrderType_Name(OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderType_descriptor(), value);
}
inline bool OrderType_Parse(
    const ::std::string& name, OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
// ===================================================================

class Date : public ::google::protobuf::Message {
 public:
  Date();
  virtual ~Date();

  Date(const Date& from);

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Date& default_instance();

  void Swap(Date* other);

  // implements Message ----------------------------------------------

  Date* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Date& from);
  void MergeFrom(const Date& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ems.Date)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Date* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hour = 1;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 1;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // optional uint32 minute = 2;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 2;
  inline ::google::protobuf::uint32 minute() const;
  inline void set_minute(::google::protobuf::uint32 value);

  // optional uint32 second = 3;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 3;
  inline ::google::protobuf::uint32 second() const;
  inline void set_second(::google::protobuf::uint32 value);

  // optional uint32 micros = 4;
  inline bool has_micros() const;
  inline void clear_micros();
  static const int kMicrosFieldNumber = 4;
  inline ::google::protobuf::uint32 micros() const;
  inline void set_micros(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ems.Time)
 private:
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_micros();
  inline void clear_has_micros();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  ::google::protobuf::uint32 second_;
  ::google::protobuf::uint32 micros_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  void Swap(Timestamp* other);

  // implements Message ----------------------------------------------

  Timestamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ems.Date date = 1;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 1;
  inline const ::pb::ems::Date& date() const;
  inline ::pb::ems::Date* mutable_date();
  inline ::pb::ems::Date* release_date();
  inline void set_allocated_date(::pb::ems::Date* date);

  // optional .pb.ems.Time time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::pb::ems::Time& time() const;
  inline ::pb::ems::Time* mutable_time();
  inline ::pb::ems::Time* release_time();
  inline void set_allocated_time(::pb::ems::Time* time);

  // optional sint32 timezone = 3;
  inline bool has_timezone() const;
  inline void clear_timezone();
  static const int kTimezoneFieldNumber = 3;
  inline ::google::protobuf::int32 timezone() const;
  inline void set_timezone(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ems.Timestamp)
 private:
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_timezone();
  inline void clear_has_timezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::ems::Date* date_;
  ::pb::ems::Time* time_;
  ::google::protobuf::int32 timezone_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Timestamp* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Status_Code Code;
  static const Code OK = Status_Code_OK;
  static const Code FAILED = Status_Code_FAILED;
  static inline bool Code_IsValid(int value) {
    return Status_Code_IsValid(value);
  }
  static const Code Code_MIN =
    Status_Code_Code_MIN;
  static const Code Code_MAX =
    Status_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    Status_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return Status_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return Status_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return Status_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.ems.Status.Code code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::pb::ems::Status_Code code() const;
  inline void set_code(::pb::ems::Status_Code value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:pb.ems.Status)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_;
  int code_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  void Swap(Order* other);

  // implements Message ----------------------------------------------

  Order* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_order_id = 1;
  inline bool has_client_order_id() const;
  inline void clear_client_order_id();
  static const int kClientOrderIdFieldNumber = 1;
  inline const ::std::string& client_order_id() const;
  inline void set_client_order_id(const ::std::string& value);
  inline void set_client_order_id(const char* value);
  inline void set_client_order_id(const char* value, size_t size);
  inline ::std::string* mutable_client_order_id();
  inline ::std::string* release_client_order_id();
  inline void set_allocated_client_order_id(::std::string* client_order_id);

  // optional string account = 9;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 9;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string contract = 10;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 10;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.ems.BuySell buy_sell = 11;
  inline bool has_buy_sell() const;
  inline void clear_buy_sell();
  static const int kBuySellFieldNumber = 11;
  inline ::pb::ems::BuySell buy_sell() const;
  inline void set_buy_sell(::pb::ems::BuySell value);

  // optional string price = 12;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 12;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional uint64 quantity = 13;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 13;
  inline ::google::protobuf::uint64 quantity() const;
  inline void set_quantity(::google::protobuf::uint64 value);

  // optional .pb.ems.TimeInForce tif = 14;
  inline bool has_tif() const;
  inline void clear_tif();
  static const int kTifFieldNumber = 14;
  inline ::pb::ems::TimeInForce tif() const;
  inline void set_tif(::pb::ems::TimeInForce value);

  // optional .pb.ems.OrderType order_type = 16;
  inline bool has_order_type() const;
  inline void clear_order_type();
  static const int kOrderTypeFieldNumber = 16;
  inline ::pb::ems::OrderType order_type() const;
  inline void set_order_type(::pb::ems::OrderType value);

  // optional string exchange_order_id = 30;
  inline bool has_exchange_order_id() const;
  inline void clear_exchange_order_id();
  static const int kExchangeOrderIdFieldNumber = 30;
  inline const ::std::string& exchange_order_id() const;
  inline void set_exchange_order_id(const ::std::string& value);
  inline void set_exchange_order_id(const char* value);
  inline void set_exchange_order_id(const char* value, size_t size);
  inline ::std::string* mutable_exchange_order_id();
  inline ::std::string* release_exchange_order_id();
  inline void set_allocated_exchange_order_id(::std::string* exchange_order_id);

  // optional .pb.ems.OrderStatus status = 31;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 31;
  inline ::pb::ems::OrderStatus status() const;
  inline void set_status(::pb::ems::OrderStatus value);

  // optional string working_price = 40;
  inline bool has_working_price() const;
  inline void clear_working_price();
  static const int kWorkingPriceFieldNumber = 40;
  inline const ::std::string& working_price() const;
  inline void set_working_price(const ::std::string& value);
  inline void set_working_price(const char* value);
  inline void set_working_price(const char* value, size_t size);
  inline ::std::string* mutable_working_price();
  inline ::std::string* release_working_price();
  inline void set_allocated_working_price(::std::string* working_price);

  // optional uint64 working_quantity = 41;
  inline bool has_working_quantity() const;
  inline void clear_working_quantity();
  static const int kWorkingQuantityFieldNumber = 41;
  inline ::google::protobuf::uint64 working_quantity() const;
  inline void set_working_quantity(::google::protobuf::uint64 value);

  // optional uint64 filled_quantity = 42;
  inline bool has_filled_quantity() const;
  inline void clear_filled_quantity();
  static const int kFilledQuantityFieldNumber = 42;
  inline ::google::protobuf::uint64 filled_quantity() const;
  inline void set_filled_quantity(::google::protobuf::uint64 value);

  // optional string message = 50;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 50;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .pb.ems.Timestamp submit_time = 60;
  inline bool has_submit_time() const;
  inline void clear_submit_time();
  static const int kSubmitTimeFieldNumber = 60;
  inline const ::pb::ems::Timestamp& submit_time() const;
  inline ::pb::ems::Timestamp* mutable_submit_time();
  inline ::pb::ems::Timestamp* release_submit_time();
  inline void set_allocated_submit_time(::pb::ems::Timestamp* submit_time);

  // @@protoc_insertion_point(class_scope:pb.ems.Order)
 private:
  inline void set_has_client_order_id();
  inline void clear_has_client_order_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_buy_sell();
  inline void clear_has_buy_sell();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_tif();
  inline void clear_has_tif();
  inline void set_has_order_type();
  inline void clear_has_order_type();
  inline void set_has_exchange_order_id();
  inline void clear_has_exchange_order_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_working_price();
  inline void clear_has_working_price();
  inline void set_has_working_quantity();
  inline void clear_has_working_quantity();
  inline void set_has_filled_quantity();
  inline void clear_has_filled_quantity();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_submit_time();
  inline void clear_has_submit_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_order_id_;
  ::std::string* account_;
  ::std::string* contract_;
  ::std::string* price_;
  int buy_sell_;
  int tif_;
  ::google::protobuf::uint64 quantity_;
  ::std::string* exchange_order_id_;
  int order_type_;
  int status_;
  ::std::string* working_price_;
  ::google::protobuf::uint64 working_quantity_;
  ::google::protobuf::uint64 filled_quantity_;
  ::std::string* message_;
  ::pb::ems::Timestamp* submit_time_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Order* default_instance_;
};
// -------------------------------------------------------------------

class Fill : public ::google::protobuf::Message {
 public:
  Fill();
  virtual ~Fill();

  Fill(const Fill& from);

  inline Fill& operator=(const Fill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fill& default_instance();

  void Swap(Fill* other);

  // implements Message ----------------------------------------------

  Fill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fill& from);
  void MergeFrom(const Fill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fill_id = 1;
  inline bool has_fill_id() const;
  inline void clear_fill_id();
  static const int kFillIdFieldNumber = 1;
  inline const ::std::string& fill_id() const;
  inline void set_fill_id(const ::std::string& value);
  inline void set_fill_id(const char* value);
  inline void set_fill_id(const char* value, size_t size);
  inline ::std::string* mutable_fill_id();
  inline ::std::string* release_fill_id();
  inline void set_allocated_fill_id(::std::string* fill_id);

  // optional string fill_price = 2;
  inline bool has_fill_price() const;
  inline void clear_fill_price();
  static const int kFillPriceFieldNumber = 2;
  inline const ::std::string& fill_price() const;
  inline void set_fill_price(const ::std::string& value);
  inline void set_fill_price(const char* value);
  inline void set_fill_price(const char* value, size_t size);
  inline ::std::string* mutable_fill_price();
  inline ::std::string* release_fill_price();
  inline void set_allocated_fill_price(::std::string* fill_price);

  // optional uint64 fill_quantity = 3;
  inline bool has_fill_quantity() const;
  inline void clear_fill_quantity();
  static const int kFillQuantityFieldNumber = 3;
  inline ::google::protobuf::uint64 fill_quantity() const;
  inline void set_fill_quantity(::google::protobuf::uint64 value);

  // optional string account = 9;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 9;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string client_order_id = 10;
  inline bool has_client_order_id() const;
  inline void clear_client_order_id();
  static const int kClientOrderIdFieldNumber = 10;
  inline const ::std::string& client_order_id() const;
  inline void set_client_order_id(const ::std::string& value);
  inline void set_client_order_id(const char* value);
  inline void set_client_order_id(const char* value, size_t size);
  inline ::std::string* mutable_client_order_id();
  inline ::std::string* release_client_order_id();
  inline void set_allocated_client_order_id(::std::string* client_order_id);

  // optional string exchange_order_id = 11;
  inline bool has_exchange_order_id() const;
  inline void clear_exchange_order_id();
  static const int kExchangeOrderIdFieldNumber = 11;
  inline const ::std::string& exchange_order_id() const;
  inline void set_exchange_order_id(const ::std::string& value);
  inline void set_exchange_order_id(const char* value);
  inline void set_exchange_order_id(const char* value, size_t size);
  inline ::std::string* mutable_exchange_order_id();
  inline ::std::string* release_exchange_order_id();
  inline void set_allocated_exchange_order_id(::std::string* exchange_order_id);

  // optional string contract = 12;
  inline bool has_contract() const;
  inline void clear_contract();
  static const int kContractFieldNumber = 12;
  inline const ::std::string& contract() const;
  inline void set_contract(const ::std::string& value);
  inline void set_contract(const char* value);
  inline void set_contract(const char* value, size_t size);
  inline ::std::string* mutable_contract();
  inline ::std::string* release_contract();
  inline void set_allocated_contract(::std::string* contract);

  // optional .pb.ems.BuySell buy_sell = 13;
  inline bool has_buy_sell() const;
  inline void clear_buy_sell();
  static const int kBuySellFieldNumber = 13;
  inline ::pb::ems::BuySell buy_sell() const;
  inline void set_buy_sell(::pb::ems::BuySell value);

  // optional .pb.ems.Timestamp fill_time = 60;
  inline bool has_fill_time() const;
  inline void clear_fill_time();
  static const int kFillTimeFieldNumber = 60;
  inline const ::pb::ems::Timestamp& fill_time() const;
  inline ::pb::ems::Timestamp* mutable_fill_time();
  inline ::pb::ems::Timestamp* release_fill_time();
  inline void set_allocated_fill_time(::pb::ems::Timestamp* fill_time);

  // @@protoc_insertion_point(class_scope:pb.ems.Fill)
 private:
  inline void set_has_fill_id();
  inline void clear_has_fill_id();
  inline void set_has_fill_price();
  inline void clear_has_fill_price();
  inline void set_has_fill_quantity();
  inline void clear_has_fill_quantity();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_client_order_id();
  inline void clear_has_client_order_id();
  inline void set_has_exchange_order_id();
  inline void clear_has_exchange_order_id();
  inline void set_has_contract();
  inline void clear_has_contract();
  inline void set_has_buy_sell();
  inline void clear_has_buy_sell();
  inline void set_has_fill_time();
  inline void clear_has_fill_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fill_id_;
  ::std::string* fill_price_;
  ::google::protobuf::uint64 fill_quantity_;
  ::std::string* account_;
  ::std::string* client_order_id_;
  ::std::string* exchange_order_id_;
  ::std::string* contract_;
  ::pb::ems::Timestamp* fill_time_;
  int buy_sell_;
  friend void  protobuf_AddDesc_ems_2eproto();
  friend void protobuf_AssignDesc_ems_2eproto();
  friend void protobuf_ShutdownFile_ems_2eproto();

  void InitAsDefaultInstance();
  static Fill* default_instance_;
};
// ===================================================================


// ===================================================================

// Date

// optional uint32 year = 1;
inline bool Date::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Date::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Date::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Date::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 Date::year() const {
  // @@protoc_insertion_point(field_get:pb.ems.Date.year)
  return year_;
}
inline void Date::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Date.year)
}

// optional uint32 month = 2;
inline bool Date::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Date::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Date::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Date::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 Date::month() const {
  // @@protoc_insertion_point(field_get:pb.ems.Date.month)
  return month_;
}
inline void Date::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Date.month)
}

// optional uint32 day = 3;
inline bool Date::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Date::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Date::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Date::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 Date::day() const {
  // @@protoc_insertion_point(field_get:pb.ems.Date.day)
  return day_;
}
inline void Date::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Date.day)
}

// -------------------------------------------------------------------

// Time

// optional uint32 hour = 1;
inline bool Time::has_hour() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_hour() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_hour() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 Time::hour() const {
  // @@protoc_insertion_point(field_get:pb.ems.Time.hour)
  return hour_;
}
inline void Time::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Time.hour)
}

// optional uint32 minute = 2;
inline bool Time::has_minute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_minute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_minute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 Time::minute() const {
  // @@protoc_insertion_point(field_get:pb.ems.Time.minute)
  return minute_;
}
inline void Time::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Time.minute)
}

// optional uint32 second = 3;
inline bool Time::has_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_second() {
  second_ = 0u;
  clear_has_second();
}
inline ::google::protobuf::uint32 Time::second() const {
  // @@protoc_insertion_point(field_get:pb.ems.Time.second)
  return second_;
}
inline void Time::set_second(::google::protobuf::uint32 value) {
  set_has_second();
  second_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Time.second)
}

// optional uint32 micros = 4;
inline bool Time::has_micros() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Time::set_has_micros() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Time::clear_has_micros() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Time::clear_micros() {
  micros_ = 0u;
  clear_has_micros();
}
inline ::google::protobuf::uint32 Time::micros() const {
  // @@protoc_insertion_point(field_get:pb.ems.Time.micros)
  return micros_;
}
inline void Time::set_micros(::google::protobuf::uint32 value) {
  set_has_micros();
  micros_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Time.micros)
}

// -------------------------------------------------------------------

// Timestamp

// optional .pb.ems.Date date = 1;
inline bool Timestamp::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamp::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamp::clear_date() {
  if (date_ != NULL) date_->::pb::ems::Date::Clear();
  clear_has_date();
}
inline const ::pb::ems::Date& Timestamp::date() const {
  // @@protoc_insertion_point(field_get:pb.ems.Timestamp.date)
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::pb::ems::Date* Timestamp::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::pb::ems::Date;
  // @@protoc_insertion_point(field_mutable:pb.ems.Timestamp.date)
  return date_;
}
inline ::pb::ems::Date* Timestamp::release_date() {
  clear_has_date();
  ::pb::ems::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void Timestamp::set_allocated_date(::pb::ems::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Timestamp.date)
}

// optional .pb.ems.Time time = 2;
inline bool Timestamp::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamp::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timestamp::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timestamp::clear_time() {
  if (time_ != NULL) time_->::pb::ems::Time::Clear();
  clear_has_time();
}
inline const ::pb::ems::Time& Timestamp::time() const {
  // @@protoc_insertion_point(field_get:pb.ems.Timestamp.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::pb::ems::Time* Timestamp::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::pb::ems::Time;
  // @@protoc_insertion_point(field_mutable:pb.ems.Timestamp.time)
  return time_;
}
inline ::pb::ems::Time* Timestamp::release_time() {
  clear_has_time();
  ::pb::ems::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Timestamp::set_allocated_time(::pb::ems::Time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Timestamp.time)
}

// optional sint32 timezone = 3;
inline bool Timestamp::has_timezone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timestamp::set_has_timezone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timestamp::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timestamp::clear_timezone() {
  timezone_ = 0;
  clear_has_timezone();
}
inline ::google::protobuf::int32 Timestamp::timezone() const {
  // @@protoc_insertion_point(field_get:pb.ems.Timestamp.timezone)
  return timezone_;
}
inline void Timestamp::set_timezone(::google::protobuf::int32 value) {
  set_has_timezone();
  timezone_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Timestamp.timezone)
}

// -------------------------------------------------------------------

// Status

// optional .pb.ems.Status.Code code = 1;
inline bool Status::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::pb::ems::Status_Code Status::code() const {
  // @@protoc_insertion_point(field_get:pb.ems.Status.code)
  return static_cast< ::pb::ems::Status_Code >(code_);
}
inline void Status::set_code(::pb::ems::Status_Code value) {
  assert(::pb::ems::Status_Code_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Status.code)
}

// optional string msg = 2;
inline bool Status::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& Status::msg() const {
  // @@protoc_insertion_point(field_get:pb.ems.Status.msg)
  return *msg_;
}
inline void Status::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Status.msg)
}
inline void Status::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Status.msg)
}
inline void Status::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Status.msg)
}
inline ::std::string* Status::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Status.msg)
  return msg_;
}
inline ::std::string* Status::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Status::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Status.msg)
}

// -------------------------------------------------------------------

// Order

// required string client_order_id = 1;
inline bool Order::has_client_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Order::set_has_client_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Order::clear_has_client_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Order::clear_client_order_id() {
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_->clear();
  }
  clear_has_client_order_id();
}
inline const ::std::string& Order::client_order_id() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.client_order_id)
  return *client_order_id_;
}
inline void Order::set_client_order_id(const ::std::string& value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.client_order_id)
}
inline void Order::set_client_order_id(const char* value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.client_order_id)
}
inline void Order::set_client_order_id(const char* value, size_t size) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.client_order_id)
}
inline ::std::string* Order::mutable_client_order_id() {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.client_order_id)
  return client_order_id_;
}
inline ::std::string* Order::release_client_order_id() {
  clear_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_order_id_;
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_client_order_id(::std::string* client_order_id) {
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_order_id_;
  }
  if (client_order_id) {
    set_has_client_order_id();
    client_order_id_ = client_order_id;
  } else {
    clear_has_client_order_id();
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.client_order_id)
}

// optional string account = 9;
inline bool Order::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Order::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Order::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Order::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& Order::account() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.account)
  return *account_;
}
inline void Order::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.account)
}
inline void Order::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.account)
}
inline void Order::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.account)
}
inline ::std::string* Order::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.account)
  return account_;
}
inline ::std::string* Order::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.account)
}

// optional string contract = 10;
inline bool Order::has_contract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Order::set_has_contract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Order::clear_has_contract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Order::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& Order::contract() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.contract)
  return *contract_;
}
inline void Order::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.contract)
}
inline void Order::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.contract)
}
inline void Order::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.contract)
}
inline ::std::string* Order::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.contract)
  return contract_;
}
inline ::std::string* Order::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.contract)
}

// optional .pb.ems.BuySell buy_sell = 11;
inline bool Order::has_buy_sell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Order::set_has_buy_sell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Order::clear_has_buy_sell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Order::clear_buy_sell() {
  buy_sell_ = 0;
  clear_has_buy_sell();
}
inline ::pb::ems::BuySell Order::buy_sell() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.buy_sell)
  return static_cast< ::pb::ems::BuySell >(buy_sell_);
}
inline void Order::set_buy_sell(::pb::ems::BuySell value) {
  assert(::pb::ems::BuySell_IsValid(value));
  set_has_buy_sell();
  buy_sell_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.buy_sell)
}

// optional string price = 12;
inline bool Order::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Order::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Order::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Order::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& Order::price() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.price)
  return *price_;
}
inline void Order::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.price)
}
inline void Order::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.price)
}
inline void Order::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.price)
}
inline ::std::string* Order::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.price)
  return price_;
}
inline ::std::string* Order::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.price)
}

// optional uint64 quantity = 13;
inline bool Order::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Order::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Order::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Order::clear_quantity() {
  quantity_ = GOOGLE_ULONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::uint64 Order::quantity() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.quantity)
  return quantity_;
}
inline void Order::set_quantity(::google::protobuf::uint64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.quantity)
}

// optional .pb.ems.TimeInForce tif = 14;
inline bool Order::has_tif() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Order::set_has_tif() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Order::clear_has_tif() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Order::clear_tif() {
  tif_ = 0;
  clear_has_tif();
}
inline ::pb::ems::TimeInForce Order::tif() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.tif)
  return static_cast< ::pb::ems::TimeInForce >(tif_);
}
inline void Order::set_tif(::pb::ems::TimeInForce value) {
  assert(::pb::ems::TimeInForce_IsValid(value));
  set_has_tif();
  tif_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.tif)
}

// optional .pb.ems.OrderType order_type = 16;
inline bool Order::has_order_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Order::set_has_order_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Order::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Order::clear_order_type() {
  order_type_ = 0;
  clear_has_order_type();
}
inline ::pb::ems::OrderType Order::order_type() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.order_type)
  return static_cast< ::pb::ems::OrderType >(order_type_);
}
inline void Order::set_order_type(::pb::ems::OrderType value) {
  assert(::pb::ems::OrderType_IsValid(value));
  set_has_order_type();
  order_type_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.order_type)
}

// optional string exchange_order_id = 30;
inline bool Order::has_exchange_order_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Order::set_has_exchange_order_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Order::clear_has_exchange_order_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Order::clear_exchange_order_id() {
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_->clear();
  }
  clear_has_exchange_order_id();
}
inline const ::std::string& Order::exchange_order_id() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.exchange_order_id)
  return *exchange_order_id_;
}
inline void Order::set_exchange_order_id(const ::std::string& value) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.exchange_order_id)
}
inline void Order::set_exchange_order_id(const char* value) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.exchange_order_id)
}
inline void Order::set_exchange_order_id(const char* value, size_t size) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.exchange_order_id)
}
inline ::std::string* Order::mutable_exchange_order_id() {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.exchange_order_id)
  return exchange_order_id_;
}
inline ::std::string* Order::release_exchange_order_id() {
  clear_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_order_id_;
    exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_exchange_order_id(::std::string* exchange_order_id) {
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_order_id_;
  }
  if (exchange_order_id) {
    set_has_exchange_order_id();
    exchange_order_id_ = exchange_order_id;
  } else {
    clear_has_exchange_order_id();
    exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.exchange_order_id)
}

// optional .pb.ems.OrderStatus status = 31;
inline bool Order::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Order::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Order::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Order::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pb::ems::OrderStatus Order::status() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.status)
  return static_cast< ::pb::ems::OrderStatus >(status_);
}
inline void Order::set_status(::pb::ems::OrderStatus value) {
  assert(::pb::ems::OrderStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.status)
}

// optional string working_price = 40;
inline bool Order::has_working_price() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Order::set_has_working_price() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Order::clear_has_working_price() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Order::clear_working_price() {
  if (working_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_price_->clear();
  }
  clear_has_working_price();
}
inline const ::std::string& Order::working_price() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.working_price)
  return *working_price_;
}
inline void Order::set_working_price(const ::std::string& value) {
  set_has_working_price();
  if (working_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_price_ = new ::std::string;
  }
  working_price_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.working_price)
}
inline void Order::set_working_price(const char* value) {
  set_has_working_price();
  if (working_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_price_ = new ::std::string;
  }
  working_price_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.working_price)
}
inline void Order::set_working_price(const char* value, size_t size) {
  set_has_working_price();
  if (working_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_price_ = new ::std::string;
  }
  working_price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.working_price)
}
inline ::std::string* Order::mutable_working_price() {
  set_has_working_price();
  if (working_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.working_price)
  return working_price_;
}
inline ::std::string* Order::release_working_price() {
  clear_has_working_price();
  if (working_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = working_price_;
    working_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_working_price(::std::string* working_price) {
  if (working_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete working_price_;
  }
  if (working_price) {
    set_has_working_price();
    working_price_ = working_price;
  } else {
    clear_has_working_price();
    working_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.working_price)
}

// optional uint64 working_quantity = 41;
inline bool Order::has_working_quantity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Order::set_has_working_quantity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Order::clear_has_working_quantity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Order::clear_working_quantity() {
  working_quantity_ = GOOGLE_ULONGLONG(0);
  clear_has_working_quantity();
}
inline ::google::protobuf::uint64 Order::working_quantity() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.working_quantity)
  return working_quantity_;
}
inline void Order::set_working_quantity(::google::protobuf::uint64 value) {
  set_has_working_quantity();
  working_quantity_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.working_quantity)
}

// optional uint64 filled_quantity = 42;
inline bool Order::has_filled_quantity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Order::set_has_filled_quantity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Order::clear_has_filled_quantity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Order::clear_filled_quantity() {
  filled_quantity_ = GOOGLE_ULONGLONG(0);
  clear_has_filled_quantity();
}
inline ::google::protobuf::uint64 Order::filled_quantity() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.filled_quantity)
  return filled_quantity_;
}
inline void Order::set_filled_quantity(::google::protobuf::uint64 value) {
  set_has_filled_quantity();
  filled_quantity_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Order.filled_quantity)
}

// optional string message = 50;
inline bool Order::has_message() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Order::set_has_message() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Order::clear_has_message() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Order::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Order::message() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.message)
  return *message_;
}
inline void Order::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Order.message)
}
inline void Order::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Order.message)
}
inline void Order::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Order.message)
}
inline ::std::string* Order::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.message)
  return message_;
}
inline ::std::string* Order::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Order::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.message)
}

// optional .pb.ems.Timestamp submit_time = 60;
inline bool Order::has_submit_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Order::set_has_submit_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Order::clear_has_submit_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Order::clear_submit_time() {
  if (submit_time_ != NULL) submit_time_->::pb::ems::Timestamp::Clear();
  clear_has_submit_time();
}
inline const ::pb::ems::Timestamp& Order::submit_time() const {
  // @@protoc_insertion_point(field_get:pb.ems.Order.submit_time)
  return submit_time_ != NULL ? *submit_time_ : *default_instance_->submit_time_;
}
inline ::pb::ems::Timestamp* Order::mutable_submit_time() {
  set_has_submit_time();
  if (submit_time_ == NULL) submit_time_ = new ::pb::ems::Timestamp;
  // @@protoc_insertion_point(field_mutable:pb.ems.Order.submit_time)
  return submit_time_;
}
inline ::pb::ems::Timestamp* Order::release_submit_time() {
  clear_has_submit_time();
  ::pb::ems::Timestamp* temp = submit_time_;
  submit_time_ = NULL;
  return temp;
}
inline void Order::set_allocated_submit_time(::pb::ems::Timestamp* submit_time) {
  delete submit_time_;
  submit_time_ = submit_time;
  if (submit_time) {
    set_has_submit_time();
  } else {
    clear_has_submit_time();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Order.submit_time)
}

// -------------------------------------------------------------------

// Fill

// required string fill_id = 1;
inline bool Fill::has_fill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fill::set_has_fill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fill::clear_has_fill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fill::clear_fill_id() {
  if (fill_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_id_->clear();
  }
  clear_has_fill_id();
}
inline const ::std::string& Fill::fill_id() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.fill_id)
  return *fill_id_;
}
inline void Fill::set_fill_id(const ::std::string& value) {
  set_has_fill_id();
  if (fill_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_id_ = new ::std::string;
  }
  fill_id_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.fill_id)
}
inline void Fill::set_fill_id(const char* value) {
  set_has_fill_id();
  if (fill_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_id_ = new ::std::string;
  }
  fill_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.fill_id)
}
inline void Fill::set_fill_id(const char* value, size_t size) {
  set_has_fill_id();
  if (fill_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_id_ = new ::std::string;
  }
  fill_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.fill_id)
}
inline ::std::string* Fill::mutable_fill_id() {
  set_has_fill_id();
  if (fill_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.fill_id)
  return fill_id_;
}
inline ::std::string* Fill::release_fill_id() {
  clear_has_fill_id();
  if (fill_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fill_id_;
    fill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_fill_id(::std::string* fill_id) {
  if (fill_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fill_id_;
  }
  if (fill_id) {
    set_has_fill_id();
    fill_id_ = fill_id;
  } else {
    clear_has_fill_id();
    fill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.fill_id)
}

// optional string fill_price = 2;
inline bool Fill::has_fill_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fill::set_has_fill_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fill::clear_has_fill_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fill::clear_fill_price() {
  if (fill_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_price_->clear();
  }
  clear_has_fill_price();
}
inline const ::std::string& Fill::fill_price() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.fill_price)
  return *fill_price_;
}
inline void Fill::set_fill_price(const ::std::string& value) {
  set_has_fill_price();
  if (fill_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_price_ = new ::std::string;
  }
  fill_price_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.fill_price)
}
inline void Fill::set_fill_price(const char* value) {
  set_has_fill_price();
  if (fill_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_price_ = new ::std::string;
  }
  fill_price_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.fill_price)
}
inline void Fill::set_fill_price(const char* value, size_t size) {
  set_has_fill_price();
  if (fill_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_price_ = new ::std::string;
  }
  fill_price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.fill_price)
}
inline ::std::string* Fill::mutable_fill_price() {
  set_has_fill_price();
  if (fill_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fill_price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.fill_price)
  return fill_price_;
}
inline ::std::string* Fill::release_fill_price() {
  clear_has_fill_price();
  if (fill_price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fill_price_;
    fill_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_fill_price(::std::string* fill_price) {
  if (fill_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fill_price_;
  }
  if (fill_price) {
    set_has_fill_price();
    fill_price_ = fill_price;
  } else {
    clear_has_fill_price();
    fill_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.fill_price)
}

// optional uint64 fill_quantity = 3;
inline bool Fill::has_fill_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fill::set_has_fill_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fill::clear_has_fill_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fill::clear_fill_quantity() {
  fill_quantity_ = GOOGLE_ULONGLONG(0);
  clear_has_fill_quantity();
}
inline ::google::protobuf::uint64 Fill::fill_quantity() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.fill_quantity)
  return fill_quantity_;
}
inline void Fill::set_fill_quantity(::google::protobuf::uint64 value) {
  set_has_fill_quantity();
  fill_quantity_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Fill.fill_quantity)
}

// optional string account = 9;
inline bool Fill::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fill::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fill::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fill::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& Fill::account() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.account)
  return *account_;
}
inline void Fill::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.account)
}
inline void Fill::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.account)
}
inline void Fill::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.account)
}
inline ::std::string* Fill::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.account)
  return account_;
}
inline ::std::string* Fill::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.account)
}

// optional string client_order_id = 10;
inline bool Fill::has_client_order_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fill::set_has_client_order_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fill::clear_has_client_order_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fill::clear_client_order_id() {
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_->clear();
  }
  clear_has_client_order_id();
}
inline const ::std::string& Fill::client_order_id() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.client_order_id)
  return *client_order_id_;
}
inline void Fill::set_client_order_id(const ::std::string& value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.client_order_id)
}
inline void Fill::set_client_order_id(const char* value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.client_order_id)
}
inline void Fill::set_client_order_id(const char* value, size_t size) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.client_order_id)
}
inline ::std::string* Fill::mutable_client_order_id() {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_order_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.client_order_id)
  return client_order_id_;
}
inline ::std::string* Fill::release_client_order_id() {
  clear_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_order_id_;
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_client_order_id(::std::string* client_order_id) {
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_order_id_;
  }
  if (client_order_id) {
    set_has_client_order_id();
    client_order_id_ = client_order_id;
  } else {
    clear_has_client_order_id();
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.client_order_id)
}

// optional string exchange_order_id = 11;
inline bool Fill::has_exchange_order_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fill::set_has_exchange_order_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Fill::clear_has_exchange_order_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Fill::clear_exchange_order_id() {
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_->clear();
  }
  clear_has_exchange_order_id();
}
inline const ::std::string& Fill::exchange_order_id() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.exchange_order_id)
  return *exchange_order_id_;
}
inline void Fill::set_exchange_order_id(const ::std::string& value) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.exchange_order_id)
}
inline void Fill::set_exchange_order_id(const char* value) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.exchange_order_id)
}
inline void Fill::set_exchange_order_id(const char* value, size_t size) {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  exchange_order_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.exchange_order_id)
}
inline ::std::string* Fill::mutable_exchange_order_id() {
  set_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_order_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.exchange_order_id)
  return exchange_order_id_;
}
inline ::std::string* Fill::release_exchange_order_id() {
  clear_has_exchange_order_id();
  if (exchange_order_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_order_id_;
    exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_exchange_order_id(::std::string* exchange_order_id) {
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_order_id_;
  }
  if (exchange_order_id) {
    set_has_exchange_order_id();
    exchange_order_id_ = exchange_order_id;
  } else {
    clear_has_exchange_order_id();
    exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.exchange_order_id)
}

// optional string contract = 12;
inline bool Fill::has_contract() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fill::set_has_contract() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Fill::clear_has_contract() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Fill::clear_contract() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_->clear();
  }
  clear_has_contract();
}
inline const ::std::string& Fill::contract() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.contract)
  return *contract_;
}
inline void Fill::set_contract(const ::std::string& value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ems.Fill.contract)
}
inline void Fill::set_contract(const char* value) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ems.Fill.contract)
}
inline void Fill::set_contract(const char* value, size_t size) {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  contract_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ems.Fill.contract)
}
inline ::std::string* Fill::mutable_contract() {
  set_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contract_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.contract)
  return contract_;
}
inline ::std::string* Fill::release_contract() {
  clear_has_contract();
  if (contract_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contract_;
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Fill::set_allocated_contract(::std::string* contract) {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (contract) {
    set_has_contract();
    contract_ = contract;
  } else {
    clear_has_contract();
    contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.contract)
}

// optional .pb.ems.BuySell buy_sell = 13;
inline bool Fill::has_buy_sell() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Fill::set_has_buy_sell() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Fill::clear_has_buy_sell() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Fill::clear_buy_sell() {
  buy_sell_ = 0;
  clear_has_buy_sell();
}
inline ::pb::ems::BuySell Fill::buy_sell() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.buy_sell)
  return static_cast< ::pb::ems::BuySell >(buy_sell_);
}
inline void Fill::set_buy_sell(::pb::ems::BuySell value) {
  assert(::pb::ems::BuySell_IsValid(value));
  set_has_buy_sell();
  buy_sell_ = value;
  // @@protoc_insertion_point(field_set:pb.ems.Fill.buy_sell)
}

// optional .pb.ems.Timestamp fill_time = 60;
inline bool Fill::has_fill_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Fill::set_has_fill_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Fill::clear_has_fill_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Fill::clear_fill_time() {
  if (fill_time_ != NULL) fill_time_->::pb::ems::Timestamp::Clear();
  clear_has_fill_time();
}
inline const ::pb::ems::Timestamp& Fill::fill_time() const {
  // @@protoc_insertion_point(field_get:pb.ems.Fill.fill_time)
  return fill_time_ != NULL ? *fill_time_ : *default_instance_->fill_time_;
}
inline ::pb::ems::Timestamp* Fill::mutable_fill_time() {
  set_has_fill_time();
  if (fill_time_ == NULL) fill_time_ = new ::pb::ems::Timestamp;
  // @@protoc_insertion_point(field_mutable:pb.ems.Fill.fill_time)
  return fill_time_;
}
inline ::pb::ems::Timestamp* Fill::release_fill_time() {
  clear_has_fill_time();
  ::pb::ems::Timestamp* temp = fill_time_;
  fill_time_ = NULL;
  return temp;
}
inline void Fill::set_allocated_fill_time(::pb::ems::Timestamp* fill_time) {
  delete fill_time_;
  fill_time_ = fill_time;
  if (fill_time) {
    set_has_fill_time();
  } else {
    clear_has_fill_time();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ems.Fill.fill_time)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ems
}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::ems::Status_Code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ems::Status_Code>() {
  return ::pb::ems::Status_Code_descriptor();
}
template <> struct is_proto_enum< ::pb::ems::BuySell> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ems::BuySell>() {
  return ::pb::ems::BuySell_descriptor();
}
template <> struct is_proto_enum< ::pb::ems::OrderStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ems::OrderStatus>() {
  return ::pb::ems::OrderStatus_descriptor();
}
template <> struct is_proto_enum< ::pb::ems::TimeInForce> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ems::TimeInForce>() {
  return ::pb::ems::TimeInForce_descriptor();
}
template <> struct is_proto_enum< ::pb::ems::OrderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ems::OrderType>() {
  return ::pb::ems::OrderType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ems_2eproto__INCLUDED
