// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ems.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ems.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace pb {
namespace ems {

namespace {

const ::google::protobuf::Descriptor* Date_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Date_reflection_ = NULL;
const ::google::protobuf::Descriptor* Time_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Time_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timestamp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timestamp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Status_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Status_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_Code_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Order_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Order_reflection_ = NULL;
const ::google::protobuf::Descriptor* Fill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Fill_reflection_ = NULL;
const ::google::protobuf::Descriptor* Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Position_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* BuySell_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TimeInForce_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* OrderType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ems_2eproto() {
  protobuf_AddDesc_ems_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ems.proto");
  GOOGLE_CHECK(file != NULL);
  Date_descriptor_ = file->message_type(0);
  static const int Date_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Date, year_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Date, month_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Date, day_),
  };
  Date_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Date_descriptor_,
      Date::default_instance_,
      Date_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Date, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Date, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Date));
  Time_descriptor_ = file->message_type(1);
  static const int Time_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, hour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, minute_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, second_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, micros_),
  };
  Time_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Time_descriptor_,
      Time::default_instance_,
      Time_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Time));
  Timestamp_descriptor_ = file->message_type(2);
  static const int Timestamp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, timezone_),
  };
  Timestamp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Timestamp_descriptor_,
      Timestamp::default_instance_,
      Timestamp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Timestamp));
  Status_descriptor_ = file->message_type(3);
  static const int Status_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, msg_),
  };
  Status_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Status_descriptor_,
      Status::default_instance_,
      Status_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Status));
  Status_Code_descriptor_ = Status_descriptor_->enum_type(0);
  Order_descriptor_ = file->message_type(4);
  static const int Order_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, client_order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, account_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, contract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, buy_sell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, quantity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, tif_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, order_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, exchange_order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, working_price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, working_quantity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, filled_quantity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, submit_time_),
  };
  Order_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Order_descriptor_,
      Order::default_instance_,
      Order_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Order));
  Fill_descriptor_ = file->message_type(5);
  static const int Fill_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, fill_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, fill_price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, fill_quantity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, account_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, client_order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, exchange_order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, contract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, buy_sell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, fill_time_),
  };
  Fill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Fill_descriptor_,
      Fill::default_instance_,
      Fill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Fill));
  Position_descriptor_ = file->message_type(6);
  static const int Position_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, contract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, account_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, position_),
  };
  Position_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Position_descriptor_,
      Position::default_instance_,
      Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Position));
  BuySell_descriptor_ = file->enum_type(0);
  OrderStatus_descriptor_ = file->enum_type(1);
  TimeInForce_descriptor_ = file->enum_type(2);
  OrderType_descriptor_ = file->enum_type(3);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ems_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Date_descriptor_, &Date::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Time_descriptor_, &Time::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Timestamp_descriptor_, &Timestamp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Status_descriptor_, &Status::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Order_descriptor_, &Order::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Fill_descriptor_, &Fill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Position_descriptor_, &Position::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ems_2eproto() {
  delete Date::default_instance_;
  delete Date_reflection_;
  delete Time::default_instance_;
  delete Time_reflection_;
  delete Timestamp::default_instance_;
  delete Timestamp_reflection_;
  delete Status::default_instance_;
  delete Status_reflection_;
  delete Order::default_instance_;
  delete Order_reflection_;
  delete Fill::default_instance_;
  delete Fill_reflection_;
  delete Position::default_instance_;
  delete Position_reflection_;
}

void protobuf_AddDesc_ems_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tems.proto\022\006pb.ems\"0\n\004Date\022\014\n\004year\030\001 \001("
    "\r\022\r\n\005month\030\002 \001(\r\022\013\n\003day\030\003 \001(\r\"D\n\004Time\022\014\n"
    "\004hour\030\001 \001(\r\022\016\n\006minute\030\002 \001(\r\022\016\n\006second\030\003 "
    "\001(\r\022\016\n\006micros\030\004 \001(\r\"U\n\tTimestamp\022\032\n\004date"
    "\030\001 \001(\0132\014.pb.ems.Date\022\032\n\004time\030\002 \001(\0132\014.pb."
    "ems.Time\022\020\n\010timezone\030\003 \001(\021\"T\n\006Status\022!\n\004"
    "code\030\001 \001(\0162\023.pb.ems.Status.Code\022\013\n\003msg\030\002"
    " \001(\t\"\032\n\004Code\022\006\n\002OK\020\000\022\n\n\006FAILED\020\001\"\223\003\n\005Ord"
    "er\022\027\n\017client_order_id\030\001 \002(\t\022\017\n\007account\030\t"
    " \001(\t\022\020\n\010contract\030\n \001(\t\022!\n\010buy_sell\030\013 \001(\016"
    "2\017.pb.ems.BuySell\022\r\n\005price\030\014 \001(\t\022\020\n\010quan"
    "tity\030\r \001(\004\022 \n\003tif\030\016 \001(\0162\023.pb.ems.TimeInF"
    "orce\022%\n\norder_type\030\020 \001(\0162\021.pb.ems.OrderT"
    "ype\022\031\n\021exchange_order_id\030\036 \001(\t\022#\n\006status"
    "\030\037 \001(\0162\023.pb.ems.OrderStatus\022\025\n\rworking_p"
    "rice\030( \001(\t\022\030\n\020working_quantity\030) \001(\004\022\027\n\017"
    "filled_quantity\030* \001(\004\022\017\n\007message\0302 \001(\t\022&"
    "\n\013submit_time\030< \001(\0132\021.pb.ems.Timestamp\"\342"
    "\001\n\004Fill\022\017\n\007fill_id\030\001 \002(\t\022\022\n\nfill_price\030\002"
    " \001(\t\022\025\n\rfill_quantity\030\003 \001(\004\022\017\n\007account\030\t"
    " \001(\t\022\027\n\017client_order_id\030\n \001(\t\022\031\n\021exchang"
    "e_order_id\030\013 \001(\t\022\020\n\010contract\030\014 \001(\t\022!\n\010bu"
    "y_sell\030\r \001(\0162\017.pb.ems.BuySell\022$\n\tfill_ti"
    "me\030< \001(\0132\021.pb.ems.Timestamp\"\?\n\010Position\022"
    "\020\n\010contract\030\001 \001(\t\022\017\n\007account\030\002 \001(\t\022\020\n\010po"
    "sition\030\n \001(\003*/\n\007BuySell\022\013\n\007BS_None\020\000\022\n\n\006"
    "BS_Buy\020\001\022\013\n\007BS_Sell\020\002*l\n\013OrderStatus\022\013\n\007"
    "OS_None\020\000\022\020\n\014OS_Cancelled\020\001\022\r\n\tOS_Filled"
    "\020\002\022\017\n\013OS_Rejected\020\003\022\016\n\nOS_Working\020\004\022\016\n\nO"
    "S_Pending\020\005*O\n\013TimeInForce\022\014\n\010TIF_None\020\000"
    "\022\013\n\007TIF_FAK\020\001\022\013\n\007TIF_FOK\020\002\022\013\n\007TIF_GFD\020\003\022"
    "\013\n\007TIF_GTC\020\004*5\n\tOrderType\022\013\n\007OT_None\020\000\022\014"
    "\n\010OT_Limit\020\001\022\r\n\tOT_Market\020\002", 1307);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ems.proto", &protobuf_RegisterTypes);
  Date::default_instance_ = new Date();
  Time::default_instance_ = new Time();
  Timestamp::default_instance_ = new Timestamp();
  Status::default_instance_ = new Status();
  Order::default_instance_ = new Order();
  Fill::default_instance_ = new Fill();
  Position::default_instance_ = new Position();
  Date::default_instance_->InitAsDefaultInstance();
  Time::default_instance_->InitAsDefaultInstance();
  Timestamp::default_instance_->InitAsDefaultInstance();
  Status::default_instance_->InitAsDefaultInstance();
  Order::default_instance_->InitAsDefaultInstance();
  Fill::default_instance_->InitAsDefaultInstance();
  Position::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ems_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ems_2eproto {
  StaticDescriptorInitializer_ems_2eproto() {
    protobuf_AddDesc_ems_2eproto();
  }
} static_descriptor_initializer_ems_2eproto_;
const ::google::protobuf::EnumDescriptor* BuySell_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuySell_descriptor_;
}
bool BuySell_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OrderStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderStatus_descriptor_;
}
bool OrderStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TimeInForce_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimeInForce_descriptor_;
}
bool TimeInForce_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OrderType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderType_descriptor_;
}
bool OrderType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Date::kYearFieldNumber;
const int Date::kMonthFieldNumber;
const int Date::kDayFieldNumber;
#endif  // !_MSC_VER

Date::Date()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Date)
}

void Date::InitAsDefaultInstance() {
}

Date::Date(const Date& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Date)
}

void Date::SharedCtor() {
  _cached_size_ = 0;
  year_ = 0u;
  month_ = 0u;
  day_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Date::~Date() {
  // @@protoc_insertion_point(destructor:pb.ems.Date)
  SharedDtor();
}

void Date::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Date::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Date::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Date_descriptor_;
}

const Date& Date::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Date* Date::default_instance_ = NULL;

Date* Date::New() const {
  return new Date;
}

void Date::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Date*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(year_, day_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Date::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Date)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 year = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &year_)));
          set_has_year();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_month;
        break;
      }

      // optional uint32 month = 2;
      case 2: {
        if (tag == 16) {
         parse_month:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &month_)));
          set_has_month();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_day;
        break;
      }

      // optional uint32 day = 3;
      case 3: {
        if (tag == 24) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Date)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Date)
  return false;
#undef DO_
}

void Date::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Date)
  // optional uint32 year = 1;
  if (has_year()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->year(), output);
  }

  // optional uint32 month = 2;
  if (has_month()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->month(), output);
  }

  // optional uint32 day = 3;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->day(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Date)
}

::google::protobuf::uint8* Date::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Date)
  // optional uint32 year = 1;
  if (has_year()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->year(), target);
  }

  // optional uint32 month = 2;
  if (has_month()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->month(), target);
  }

  // optional uint32 day = 3;
  if (has_day()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->day(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Date)
  return target;
}

int Date::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 year = 1;
    if (has_year()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->year());
    }

    // optional uint32 month = 2;
    if (has_month()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->month());
    }

    // optional uint32 day = 3;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Date::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Date* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Date*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Date::MergeFrom(const Date& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_year()) {
      set_year(from.year());
    }
    if (from.has_month()) {
      set_month(from.month());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Date::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Date::CopyFrom(const Date& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Date::IsInitialized() const {

  return true;
}

void Date::Swap(Date* other) {
  if (other != this) {
    std::swap(year_, other->year_);
    std::swap(month_, other->month_);
    std::swap(day_, other->day_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Date::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Date_descriptor_;
  metadata.reflection = Date_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Time::kHourFieldNumber;
const int Time::kMinuteFieldNumber;
const int Time::kSecondFieldNumber;
const int Time::kMicrosFieldNumber;
#endif  // !_MSC_VER

Time::Time()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Time)
}

void Time::InitAsDefaultInstance() {
}

Time::Time(const Time& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Time)
}

void Time::SharedCtor() {
  _cached_size_ = 0;
  hour_ = 0u;
  minute_ = 0u;
  second_ = 0u;
  micros_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:pb.ems.Time)
  SharedDtor();
}

void Time::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Time::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Time_descriptor_;
}

const Time& Time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Time* Time::default_instance_ = NULL;

Time* Time::New() const {
  return new Time;
}

void Time::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Time*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(hour_, micros_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Time)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 hour = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hour_)));
          set_has_hour();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_minute;
        break;
      }

      // optional uint32 minute = 2;
      case 2: {
        if (tag == 16) {
         parse_minute:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minute_)));
          set_has_minute();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_second;
        break;
      }

      // optional uint32 second = 3;
      case 3: {
        if (tag == 24) {
         parse_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &second_)));
          set_has_second();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_micros;
        break;
      }

      // optional uint32 micros = 4;
      case 4: {
        if (tag == 32) {
         parse_micros:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &micros_)));
          set_has_micros();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Time)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Time)
  return false;
#undef DO_
}

void Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Time)
  // optional uint32 hour = 1;
  if (has_hour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->hour(), output);
  }

  // optional uint32 minute = 2;
  if (has_minute()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->minute(), output);
  }

  // optional uint32 second = 3;
  if (has_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->second(), output);
  }

  // optional uint32 micros = 4;
  if (has_micros()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->micros(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Time)
}

::google::protobuf::uint8* Time::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Time)
  // optional uint32 hour = 1;
  if (has_hour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->hour(), target);
  }

  // optional uint32 minute = 2;
  if (has_minute()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->minute(), target);
  }

  // optional uint32 second = 3;
  if (has_second()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->second(), target);
  }

  // optional uint32 micros = 4;
  if (has_micros()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->micros(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Time)
  return target;
}

int Time::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 hour = 1;
    if (has_hour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hour());
    }

    // optional uint32 minute = 2;
    if (has_minute()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minute());
    }

    // optional uint32 second = 3;
    if (has_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->second());
    }

    // optional uint32 micros = 4;
    if (has_micros()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->micros());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Time::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Time* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Time*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Time::MergeFrom(const Time& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hour()) {
      set_hour(from.hour());
    }
    if (from.has_minute()) {
      set_minute(from.minute());
    }
    if (from.has_second()) {
      set_second(from.second());
    }
    if (from.has_micros()) {
      set_micros(from.micros());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Time::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Time::CopyFrom(const Time& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {

  return true;
}

void Time::Swap(Time* other) {
  if (other != this) {
    std::swap(hour_, other->hour_);
    std::swap(minute_, other->minute_);
    std::swap(second_, other->second_);
    std::swap(micros_, other->micros_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Time::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Time_descriptor_;
  metadata.reflection = Time_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Timestamp::kDateFieldNumber;
const int Timestamp::kTimeFieldNumber;
const int Timestamp::kTimezoneFieldNumber;
#endif  // !_MSC_VER

Timestamp::Timestamp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Timestamp)
}

void Timestamp::InitAsDefaultInstance() {
  date_ = const_cast< ::pb::ems::Date*>(&::pb::ems::Date::default_instance());
  time_ = const_cast< ::pb::ems::Time*>(&::pb::ems::Time::default_instance());
}

Timestamp::Timestamp(const Timestamp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Timestamp)
}

void Timestamp::SharedCtor() {
  _cached_size_ = 0;
  date_ = NULL;
  time_ = NULL;
  timezone_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:pb.ems.Timestamp)
  SharedDtor();
}

void Timestamp::SharedDtor() {
  if (this != default_instance_) {
    delete date_;
    delete time_;
  }
}

void Timestamp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timestamp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timestamp_descriptor_;
}

const Timestamp& Timestamp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Timestamp* Timestamp::default_instance_ = NULL;

Timestamp* Timestamp::New() const {
  return new Timestamp;
}

void Timestamp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_date()) {
      if (date_ != NULL) date_->::pb::ems::Date::Clear();
    }
    if (has_time()) {
      if (time_ != NULL) time_->::pb::ems::Time::Clear();
    }
    timezone_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Timestamp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Timestamp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pb.ems.Date date = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_date()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_time;
        break;
      }

      // optional .pb.ems.Time time = 2;
      case 2: {
        if (tag == 18) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timezone;
        break;
      }

      // optional sint32 timezone = 3;
      case 3: {
        if (tag == 24) {
         parse_timezone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &timezone_)));
          set_has_timezone();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Timestamp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Timestamp)
  return false;
#undef DO_
}

void Timestamp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Timestamp)
  // optional .pb.ems.Date date = 1;
  if (has_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->date(), output);
  }

  // optional .pb.ems.Time time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->time(), output);
  }

  // optional sint32 timezone = 3;
  if (has_timezone()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->timezone(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Timestamp)
}

::google::protobuf::uint8* Timestamp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Timestamp)
  // optional .pb.ems.Date date = 1;
  if (has_date()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->date(), target);
  }

  // optional .pb.ems.Time time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->time(), target);
  }

  // optional sint32 timezone = 3;
  if (has_timezone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->timezone(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Timestamp)
  return target;
}

int Timestamp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .pb.ems.Date date = 1;
    if (has_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->date());
    }

    // optional .pb.ems.Time time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }

    // optional sint32 timezone = 3;
    if (has_timezone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->timezone());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timestamp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Timestamp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Timestamp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timestamp::MergeFrom(const Timestamp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_date()) {
      mutable_date()->::pb::ems::Date::MergeFrom(from.date());
    }
    if (from.has_time()) {
      mutable_time()->::pb::ems::Time::MergeFrom(from.time());
    }
    if (from.has_timezone()) {
      set_timezone(from.timezone());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Timestamp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timestamp::CopyFrom(const Timestamp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {

  return true;
}

void Timestamp::Swap(Timestamp* other) {
  if (other != this) {
    std::swap(date_, other->date_);
    std::swap(time_, other->time_);
    std::swap(timezone_, other->timezone_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Timestamp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timestamp_descriptor_;
  metadata.reflection = Timestamp_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Status_Code_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_Code_descriptor_;
}
bool Status_Code_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Status_Code Status::OK;
const Status_Code Status::FAILED;
const Status_Code Status::Code_MIN;
const Status_Code Status::Code_MAX;
const int Status::Code_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Status::kCodeFieldNumber;
const int Status::kMsgFieldNumber;
#endif  // !_MSC_VER

Status::Status()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Status)
}

void Status::InitAsDefaultInstance() {
}

Status::Status(const Status& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Status)
}

void Status::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  code_ = 0;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:pb.ems.Status)
  SharedDtor();
}

void Status::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (this != default_instance_) {
  }
}

void Status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Status::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}

const Status& Status::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Status* Status::default_instance_ = NULL;

Status* Status::New() const {
  return new Status;
}

void Status::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    code_ = 0;
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Status)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pb.ems.Status.Code code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::Status_Code_IsValid(value)) {
            set_code(static_cast< ::pb::ems::Status_Code >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }

      // optional string msg = 2;
      case 2: {
        if (tag == 18) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->msg().data(), this->msg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "msg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Status)
  return false;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Status)
  // optional .pb.ems.Status.Code code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "msg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->msg(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Status)
}

::google::protobuf::uint8* Status::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Status)
  // optional .pb.ems.Status.Code code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "msg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->msg(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Status)
  return target;
}

int Status::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .pb.ems.Status.Code code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Status* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Status*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {

  return true;
}

void Status::Swap(Status* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(msg_, other->msg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Status::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Status_descriptor_;
  metadata.reflection = Status_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Order::kClientOrderIdFieldNumber;
const int Order::kAccountFieldNumber;
const int Order::kContractFieldNumber;
const int Order::kBuySellFieldNumber;
const int Order::kPriceFieldNumber;
const int Order::kQuantityFieldNumber;
const int Order::kTifFieldNumber;
const int Order::kOrderTypeFieldNumber;
const int Order::kExchangeOrderIdFieldNumber;
const int Order::kStatusFieldNumber;
const int Order::kWorkingPriceFieldNumber;
const int Order::kWorkingQuantityFieldNumber;
const int Order::kFilledQuantityFieldNumber;
const int Order::kMessageFieldNumber;
const int Order::kSubmitTimeFieldNumber;
#endif  // !_MSC_VER

Order::Order()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Order)
}

void Order::InitAsDefaultInstance() {
  submit_time_ = const_cast< ::pb::ems::Timestamp*>(&::pb::ems::Timestamp::default_instance());
}

Order::Order(const Order& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Order)
}

void Order::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  buy_sell_ = 0;
  price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quantity_ = GOOGLE_ULONGLONG(0);
  tif_ = 0;
  order_type_ = 0;
  exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_ = 0;
  working_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  working_quantity_ = GOOGLE_ULONGLONG(0);
  filled_quantity_ = GOOGLE_ULONGLONG(0);
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  submit_time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:pb.ems.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_order_id_;
  }
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_order_id_;
  }
  if (working_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete working_price_;
  }
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
    delete submit_time_;
  }
}

void Order::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Order::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Order_descriptor_;
}

const Order& Order::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Order* Order::default_instance_ = NULL;

Order* Order::New() const {
  return new Order;
}

void Order::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Order*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(buy_sell_, quantity_);
    if (has_client_order_id()) {
      if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        client_order_id_->clear();
      }
    }
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        account_->clear();
      }
    }
    if (has_contract()) {
      if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contract_->clear();
      }
    }
    if (has_price()) {
      if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        price_->clear();
      }
    }
    order_type_ = 0;
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(working_quantity_, filled_quantity_);
    if (has_exchange_order_id()) {
      if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        exchange_order_id_->clear();
      }
    }
    status_ = 0;
    if (has_working_price()) {
      if (working_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        working_price_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    if (has_submit_time()) {
      if (submit_time_ != NULL) submit_time_->::pb::ems::Timestamp::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Order)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string client_order_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_order_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_order_id().data(), this->client_order_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "client_order_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_account;
        break;
      }

      // optional string account = 9;
      case 9: {
        if (tag == 74) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "account");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_contract;
        break;
      }

      // optional string contract = 10;
      case 10: {
        if (tag == 82) {
         parse_contract:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contract()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->contract().data(), this->contract().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "contract");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_buy_sell;
        break;
      }

      // optional .pb.ems.BuySell buy_sell = 11;
      case 11: {
        if (tag == 88) {
         parse_buy_sell:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::BuySell_IsValid(value)) {
            set_buy_sell(static_cast< ::pb::ems::BuySell >(value));
          } else {
            mutable_unknown_fields()->AddVarint(11, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_price;
        break;
      }

      // optional string price = 12;
      case 12: {
        if (tag == 98) {
         parse_price:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_price()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->price().data(), this->price().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "price");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_quantity;
        break;
      }

      // optional uint64 quantity = 13;
      case 13: {
        if (tag == 104) {
         parse_quantity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quantity_)));
          set_has_quantity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_tif;
        break;
      }

      // optional .pb.ems.TimeInForce tif = 14;
      case 14: {
        if (tag == 112) {
         parse_tif:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::TimeInForce_IsValid(value)) {
            set_tif(static_cast< ::pb::ems::TimeInForce >(value));
          } else {
            mutable_unknown_fields()->AddVarint(14, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_order_type;
        break;
      }

      // optional .pb.ems.OrderType order_type = 16;
      case 16: {
        if (tag == 128) {
         parse_order_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::OrderType_IsValid(value)) {
            set_order_type(static_cast< ::pb::ems::OrderType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(16, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_exchange_order_id;
        break;
      }

      // optional string exchange_order_id = 30;
      case 30: {
        if (tag == 242) {
         parse_exchange_order_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exchange_order_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->exchange_order_id().data(), this->exchange_order_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "exchange_order_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_status;
        break;
      }

      // optional .pb.ems.OrderStatus status = 31;
      case 31: {
        if (tag == 248) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::OrderStatus_IsValid(value)) {
            set_status(static_cast< ::pb::ems::OrderStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(31, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(322)) goto parse_working_price;
        break;
      }

      // optional string working_price = 40;
      case 40: {
        if (tag == 322) {
         parse_working_price:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_working_price()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->working_price().data(), this->working_price().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "working_price");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_working_quantity;
        break;
      }

      // optional uint64 working_quantity = 41;
      case 41: {
        if (tag == 328) {
         parse_working_quantity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &working_quantity_)));
          set_has_working_quantity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_filled_quantity;
        break;
      }

      // optional uint64 filled_quantity = 42;
      case 42: {
        if (tag == 336) {
         parse_filled_quantity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filled_quantity_)));
          set_has_filled_quantity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(402)) goto parse_message;
        break;
      }

      // optional string message = 50;
      case 50: {
        if (tag == 402) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(482)) goto parse_submit_time;
        break;
      }

      // optional .pb.ems.Timestamp submit_time = 60;
      case 60: {
        if (tag == 482) {
         parse_submit_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_submit_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Order)
  // required string client_order_id = 1;
  if (has_client_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_order_id().data(), this->client_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "client_order_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_order_id(), output);
  }

  // optional string account = 9;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->account(), output);
  }

  // optional string contract = 10;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->contract(), output);
  }

  // optional .pb.ems.BuySell buy_sell = 11;
  if (has_buy_sell()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->buy_sell(), output);
  }

  // optional string price = 12;
  if (has_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->price().data(), this->price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "price");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->price(), output);
  }

  // optional uint64 quantity = 13;
  if (has_quantity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->quantity(), output);
  }

  // optional .pb.ems.TimeInForce tif = 14;
  if (has_tif()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      14, this->tif(), output);
  }

  // optional .pb.ems.OrderType order_type = 16;
  if (has_order_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      16, this->order_type(), output);
  }

  // optional string exchange_order_id = 30;
  if (has_exchange_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exchange_order_id().data(), this->exchange_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "exchange_order_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      30, this->exchange_order_id(), output);
  }

  // optional .pb.ems.OrderStatus status = 31;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      31, this->status(), output);
  }

  // optional string working_price = 40;
  if (has_working_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->working_price().data(), this->working_price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "working_price");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      40, this->working_price(), output);
  }

  // optional uint64 working_quantity = 41;
  if (has_working_quantity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(41, this->working_quantity(), output);
  }

  // optional uint64 filled_quantity = 42;
  if (has_filled_quantity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(42, this->filled_quantity(), output);
  }

  // optional string message = 50;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      50, this->message(), output);
  }

  // optional .pb.ems.Timestamp submit_time = 60;
  if (has_submit_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      60, this->submit_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Order)
}

::google::protobuf::uint8* Order::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Order)
  // required string client_order_id = 1;
  if (has_client_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_order_id().data(), this->client_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "client_order_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->client_order_id(), target);
  }

  // optional string account = 9;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->account(), target);
  }

  // optional string contract = 10;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->contract(), target);
  }

  // optional .pb.ems.BuySell buy_sell = 11;
  if (has_buy_sell()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->buy_sell(), target);
  }

  // optional string price = 12;
  if (has_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->price().data(), this->price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "price");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->price(), target);
  }

  // optional uint64 quantity = 13;
  if (has_quantity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->quantity(), target);
  }

  // optional .pb.ems.TimeInForce tif = 14;
  if (has_tif()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      14, this->tif(), target);
  }

  // optional .pb.ems.OrderType order_type = 16;
  if (has_order_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      16, this->order_type(), target);
  }

  // optional string exchange_order_id = 30;
  if (has_exchange_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exchange_order_id().data(), this->exchange_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "exchange_order_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->exchange_order_id(), target);
  }

  // optional .pb.ems.OrderStatus status = 31;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      31, this->status(), target);
  }

  // optional string working_price = 40;
  if (has_working_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->working_price().data(), this->working_price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "working_price");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        40, this->working_price(), target);
  }

  // optional uint64 working_quantity = 41;
  if (has_working_quantity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(41, this->working_quantity(), target);
  }

  // optional uint64 filled_quantity = 42;
  if (has_filled_quantity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(42, this->filled_quantity(), target);
  }

  // optional string message = 50;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        50, this->message(), target);
  }

  // optional .pb.ems.Timestamp submit_time = 60;
  if (has_submit_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        60, this->submit_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Order)
  return target;
}

int Order::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string client_order_id = 1;
    if (has_client_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_order_id());
    }

    // optional string account = 9;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string contract = 10;
    if (has_contract()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contract());
    }

    // optional .pb.ems.BuySell buy_sell = 11;
    if (has_buy_sell()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->buy_sell());
    }

    // optional string price = 12;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->price());
    }

    // optional uint64 quantity = 13;
    if (has_quantity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quantity());
    }

    // optional .pb.ems.TimeInForce tif = 14;
    if (has_tif()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tif());
    }

    // optional .pb.ems.OrderType order_type = 16;
    if (has_order_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->order_type());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string exchange_order_id = 30;
    if (has_exchange_order_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exchange_order_id());
    }

    // optional .pb.ems.OrderStatus status = 31;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string working_price = 40;
    if (has_working_price()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->working_price());
    }

    // optional uint64 working_quantity = 41;
    if (has_working_quantity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->working_quantity());
    }

    // optional uint64 filled_quantity = 42;
    if (has_filled_quantity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->filled_quantity());
    }

    // optional string message = 50;
    if (has_message()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .pb.ems.Timestamp submit_time = 60;
    if (has_submit_time()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->submit_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Order::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Order* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Order*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Order::MergeFrom(const Order& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_order_id()) {
      set_client_order_id(from.client_order_id());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_contract()) {
      set_contract(from.contract());
    }
    if (from.has_buy_sell()) {
      set_buy_sell(from.buy_sell());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_quantity()) {
      set_quantity(from.quantity());
    }
    if (from.has_tif()) {
      set_tif(from.tif());
    }
    if (from.has_order_type()) {
      set_order_type(from.order_type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_exchange_order_id()) {
      set_exchange_order_id(from.exchange_order_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_working_price()) {
      set_working_price(from.working_price());
    }
    if (from.has_working_quantity()) {
      set_working_quantity(from.working_quantity());
    }
    if (from.has_filled_quantity()) {
      set_filled_quantity(from.filled_quantity());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_submit_time()) {
      mutable_submit_time()->::pb::ems::Timestamp::MergeFrom(from.submit_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Order::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Order::CopyFrom(const Order& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Order::Swap(Order* other) {
  if (other != this) {
    std::swap(client_order_id_, other->client_order_id_);
    std::swap(account_, other->account_);
    std::swap(contract_, other->contract_);
    std::swap(buy_sell_, other->buy_sell_);
    std::swap(price_, other->price_);
    std::swap(quantity_, other->quantity_);
    std::swap(tif_, other->tif_);
    std::swap(order_type_, other->order_type_);
    std::swap(exchange_order_id_, other->exchange_order_id_);
    std::swap(status_, other->status_);
    std::swap(working_price_, other->working_price_);
    std::swap(working_quantity_, other->working_quantity_);
    std::swap(filled_quantity_, other->filled_quantity_);
    std::swap(message_, other->message_);
    std::swap(submit_time_, other->submit_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Order::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Order_descriptor_;
  metadata.reflection = Order_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Fill::kFillIdFieldNumber;
const int Fill::kFillPriceFieldNumber;
const int Fill::kFillQuantityFieldNumber;
const int Fill::kAccountFieldNumber;
const int Fill::kClientOrderIdFieldNumber;
const int Fill::kExchangeOrderIdFieldNumber;
const int Fill::kContractFieldNumber;
const int Fill::kBuySellFieldNumber;
const int Fill::kFillTimeFieldNumber;
#endif  // !_MSC_VER

Fill::Fill()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Fill)
}

void Fill::InitAsDefaultInstance() {
  fill_time_ = const_cast< ::pb::ems::Timestamp*>(&::pb::ems::Timestamp::default_instance());
}

Fill::Fill(const Fill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Fill)
}

void Fill::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  fill_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fill_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fill_quantity_ = GOOGLE_ULONGLONG(0);
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  exchange_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  buy_sell_ = 0;
  fill_time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Fill::~Fill() {
  // @@protoc_insertion_point(destructor:pb.ems.Fill)
  SharedDtor();
}

void Fill::SharedDtor() {
  if (fill_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fill_id_;
  }
  if (fill_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fill_price_;
  }
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_order_id_;
  }
  if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_order_id_;
  }
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (this != default_instance_) {
    delete fill_time_;
  }
}

void Fill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Fill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Fill_descriptor_;
}

const Fill& Fill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Fill* Fill::default_instance_ = NULL;

Fill* Fill::New() const {
  return new Fill;
}

void Fill::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_fill_id()) {
      if (fill_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fill_id_->clear();
      }
    }
    if (has_fill_price()) {
      if (fill_price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fill_price_->clear();
      }
    }
    fill_quantity_ = GOOGLE_ULONGLONG(0);
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        account_->clear();
      }
    }
    if (has_client_order_id()) {
      if (client_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        client_order_id_->clear();
      }
    }
    if (has_exchange_order_id()) {
      if (exchange_order_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        exchange_order_id_->clear();
      }
    }
    if (has_contract()) {
      if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contract_->clear();
      }
    }
    buy_sell_ = 0;
  }
  if (has_fill_time()) {
    if (fill_time_ != NULL) fill_time_->::pb::ems::Timestamp::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Fill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Fill)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string fill_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fill_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->fill_id().data(), this->fill_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "fill_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_fill_price;
        break;
      }

      // optional string fill_price = 2;
      case 2: {
        if (tag == 18) {
         parse_fill_price:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fill_price()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->fill_price().data(), this->fill_price().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "fill_price");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_fill_quantity;
        break;
      }

      // optional uint64 fill_quantity = 3;
      case 3: {
        if (tag == 24) {
         parse_fill_quantity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fill_quantity_)));
          set_has_fill_quantity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_account;
        break;
      }

      // optional string account = 9;
      case 9: {
        if (tag == 74) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "account");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_client_order_id;
        break;
      }

      // optional string client_order_id = 10;
      case 10: {
        if (tag == 82) {
         parse_client_order_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_order_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_order_id().data(), this->client_order_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "client_order_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_exchange_order_id;
        break;
      }

      // optional string exchange_order_id = 11;
      case 11: {
        if (tag == 90) {
         parse_exchange_order_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exchange_order_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->exchange_order_id().data(), this->exchange_order_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "exchange_order_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_contract;
        break;
      }

      // optional string contract = 12;
      case 12: {
        if (tag == 98) {
         parse_contract:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contract()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->contract().data(), this->contract().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "contract");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_buy_sell;
        break;
      }

      // optional .pb.ems.BuySell buy_sell = 13;
      case 13: {
        if (tag == 104) {
         parse_buy_sell:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::ems::BuySell_IsValid(value)) {
            set_buy_sell(static_cast< ::pb::ems::BuySell >(value));
          } else {
            mutable_unknown_fields()->AddVarint(13, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(482)) goto parse_fill_time;
        break;
      }

      // optional .pb.ems.Timestamp fill_time = 60;
      case 60: {
        if (tag == 482) {
         parse_fill_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fill_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Fill)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Fill)
  return false;
#undef DO_
}

void Fill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Fill)
  // required string fill_id = 1;
  if (has_fill_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fill_id().data(), this->fill_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fill_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->fill_id(), output);
  }

  // optional string fill_price = 2;
  if (has_fill_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fill_price().data(), this->fill_price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fill_price");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->fill_price(), output);
  }

  // optional uint64 fill_quantity = 3;
  if (has_fill_quantity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->fill_quantity(), output);
  }

  // optional string account = 9;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->account(), output);
  }

  // optional string client_order_id = 10;
  if (has_client_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_order_id().data(), this->client_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "client_order_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->client_order_id(), output);
  }

  // optional string exchange_order_id = 11;
  if (has_exchange_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exchange_order_id().data(), this->exchange_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "exchange_order_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->exchange_order_id(), output);
  }

  // optional string contract = 12;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->contract(), output);
  }

  // optional .pb.ems.BuySell buy_sell = 13;
  if (has_buy_sell()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      13, this->buy_sell(), output);
  }

  // optional .pb.ems.Timestamp fill_time = 60;
  if (has_fill_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      60, this->fill_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Fill)
}

::google::protobuf::uint8* Fill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Fill)
  // required string fill_id = 1;
  if (has_fill_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fill_id().data(), this->fill_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fill_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->fill_id(), target);
  }

  // optional string fill_price = 2;
  if (has_fill_price()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fill_price().data(), this->fill_price().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fill_price");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->fill_price(), target);
  }

  // optional uint64 fill_quantity = 3;
  if (has_fill_quantity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->fill_quantity(), target);
  }

  // optional string account = 9;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->account(), target);
  }

  // optional string client_order_id = 10;
  if (has_client_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_order_id().data(), this->client_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "client_order_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->client_order_id(), target);
  }

  // optional string exchange_order_id = 11;
  if (has_exchange_order_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exchange_order_id().data(), this->exchange_order_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "exchange_order_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->exchange_order_id(), target);
  }

  // optional string contract = 12;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->contract(), target);
  }

  // optional .pb.ems.BuySell buy_sell = 13;
  if (has_buy_sell()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      13, this->buy_sell(), target);
  }

  // optional .pb.ems.Timestamp fill_time = 60;
  if (has_fill_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        60, this->fill_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Fill)
  return target;
}

int Fill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string fill_id = 1;
    if (has_fill_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fill_id());
    }

    // optional string fill_price = 2;
    if (has_fill_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fill_price());
    }

    // optional uint64 fill_quantity = 3;
    if (has_fill_quantity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fill_quantity());
    }

    // optional string account = 9;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string client_order_id = 10;
    if (has_client_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_order_id());
    }

    // optional string exchange_order_id = 11;
    if (has_exchange_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exchange_order_id());
    }

    // optional string contract = 12;
    if (has_contract()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contract());
    }

    // optional .pb.ems.BuySell buy_sell = 13;
    if (has_buy_sell()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->buy_sell());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .pb.ems.Timestamp fill_time = 60;
    if (has_fill_time()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fill_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Fill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Fill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Fill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Fill::MergeFrom(const Fill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fill_id()) {
      set_fill_id(from.fill_id());
    }
    if (from.has_fill_price()) {
      set_fill_price(from.fill_price());
    }
    if (from.has_fill_quantity()) {
      set_fill_quantity(from.fill_quantity());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_client_order_id()) {
      set_client_order_id(from.client_order_id());
    }
    if (from.has_exchange_order_id()) {
      set_exchange_order_id(from.exchange_order_id());
    }
    if (from.has_contract()) {
      set_contract(from.contract());
    }
    if (from.has_buy_sell()) {
      set_buy_sell(from.buy_sell());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_fill_time()) {
      mutable_fill_time()->::pb::ems::Timestamp::MergeFrom(from.fill_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Fill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fill::CopyFrom(const Fill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Fill::Swap(Fill* other) {
  if (other != this) {
    std::swap(fill_id_, other->fill_id_);
    std::swap(fill_price_, other->fill_price_);
    std::swap(fill_quantity_, other->fill_quantity_);
    std::swap(account_, other->account_);
    std::swap(client_order_id_, other->client_order_id_);
    std::swap(exchange_order_id_, other->exchange_order_id_);
    std::swap(contract_, other->contract_);
    std::swap(buy_sell_, other->buy_sell_);
    std::swap(fill_time_, other->fill_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Fill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Fill_descriptor_;
  metadata.reflection = Fill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Position::kContractFieldNumber;
const int Position::kAccountFieldNumber;
const int Position::kPositionFieldNumber;
#endif  // !_MSC_VER

Position::Position()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.ems.Position)
}

void Position::InitAsDefaultInstance() {
}

Position::Position(const Position& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.ems.Position)
}

void Position::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  contract_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  position_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:pb.ems.Position)
  SharedDtor();
}

void Position::SharedDtor() {
  if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contract_;
  }
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (this != default_instance_) {
  }
}

void Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Position_descriptor_;
}

const Position& Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ems_2eproto();
  return *default_instance_;
}

Position* Position::default_instance_ = NULL;

Position* Position::New() const {
  return new Position;
}

void Position::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_contract()) {
      if (contract_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contract_->clear();
      }
    }
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        account_->clear();
      }
    }
    position_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.ems.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string contract = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contract()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->contract().data(), this->contract().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "contract");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (tag == 18) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->account().data(), this->account().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "account");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_position;
        break;
      }

      // optional int64 position = 10;
      case 10: {
        if (tag == 80) {
         parse_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.ems.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.ems.Position)
  return false;
#undef DO_
}

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.ems.Position)
  // optional string contract = 1;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->contract(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->account(), output);
  }

  // optional int64 position = 10;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->position(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.ems.Position)
}

::google::protobuf::uint8* Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.ems.Position)
  // optional string contract = 1;
  if (has_contract()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->contract().data(), this->contract().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "contract");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->contract(), target);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->account().data(), this->account().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "account");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->account(), target);
  }

  // optional int64 position = 10;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->position(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.ems.Position)
  return target;
}

int Position::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string contract = 1;
    if (has_contract()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contract());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional int64 position = 10;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->position());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Position* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Position*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contract()) {
      set_contract(from.contract());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {

  return true;
}

void Position::Swap(Position* other) {
  if (other != this) {
    std::swap(contract_, other->contract_);
    std::swap(account_, other->account_);
    std::swap(position_, other->position_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Position_descriptor_;
  metadata.reflection = Position_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ems
}  // namespace pb

// @@protoc_insertion_point(global_scope)
